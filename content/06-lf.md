<!--label:lf-->
# 語言特徵

**[抽象型式](types-abstract)：**

抽象型式是編譯期構造，其在執行期以不同的方式表述。這容許給已存在的型式以全新的含意。

**[外部類別](lf-externs)：**

外部可用於以型式安全的方式描述目標特定的互動。

**[匿名結構](types-anonymous-structure)**

data(資料|) can easily be grouped in anonymous(匿名|) structure(結構|)s, minimizing the necessity of small data(資料|) class(類別|)es.

```haxe
var point = {x: 0, y: 10};
point.x += 10;
```

**[Array Comprehension](lf-array-comprehension):**

Create and populate arrays quickly using for loops and logic.

```haxe
var evenNumbers = [for (i in 0...100) if (i & 1 == 0) i];
```

**[Map Comprehension](lf-map-comprehension):**

Create and populate maps quickly using for loops and logic.

```haxe
var primality = [for (i in 0...100) i => isPrime(i)];
```

**[Classes, interfaces and inheritance](types-class-instance):**

Haxe allows structuring code in classes, making it an object-oriented language. Common related features known from languages such as Java are supported, including inheritance and interfaces.

**[Conditional compilation](lf-condition-compilation):**

Conditional Compilation allows compiling specific code depending on compilation parameters. This is instrumental for abstracting target-specific differences, but can also be used for other purposes, such as more detailed debugging.

```haxe
#if js
  js.Browser.alert("Hello");
#elseif sys
  Sys.println("Hello");
#end
```

**[(Generalized) Algebraic Data Types](types-enum-instance):**

Structure can be expressed through algebraic data types (ADT), which are known as enums in the Haxe Language. Furthermore, Haxe supports their generalized variant known as GADT.

```haxe
enum Result {
  Success(data:Array<Int>);
  UserError(msg:String);
  SystemError(msg:String, position:PosInfos);
}
```

**[Inlined calls](class-field-inline):**

Functions can be designated as being inline, allowing their code to be inserted at call-site. This can yield significant performance benefits without resorting to code duplication via manual inlining.

**[Iterators](lf-iterators):**

Iterating over a set of values, e.g. the elements of an array, is very easy in Haxe courtesy of iterators. Custom classes can quickly implement iterator functionality to allow iteration.

```haxe
for (i in [1, 2, 3]) {
  trace(i);
}
```

**[Local functions and closures](expression-arrow-function):**

Functions in Haxe are not limited to class fields and can be declared in expressions as well, allowing powerful closures.

```haxe
var buffer = "";
function append(s:String) {
  buffer += s;
}
append("foo");
append("bar");
trace(buffer); // foobar
```

**[Metadata](lf-metadata):**

Add metadata to fields, classes or expressions. This can communicate information to the compiler, macros, or runtime classes.

```haxe
class MyClass {
  @range(1, 8) var value:Int;
}
trace(haxe.rtti.Meta.getFields(MyClass).value.range); // [1,8]
```

**[Static Extensions](lf-static-extension):**

Existing classes and other types can be augmented with additional functionality through using static extensions.

```haxe
using StringTools;
"  Me & You    ".trim().htmlEscape();
```

**[String Interpolation](lf-string-interpolation):**

Strings declared with a single quotes are able to access variables in the current context.

```haxe
trace('My name is $name and I work in ${job.industry}');
```

**[Partial function application](lf-function-bindings):**

Any function can be applied partially, providing the values of some arguments and leaving the rest to be filled in later.

```haxe
var map = new haxe.ds.IntMap();
var setToTwelve = map.set.bind(_, 12);
setToTwelve(1);
setToTwelve(2);
```

**[Pattern Matching](lf-pattern-matching):**

Complex structures can be matched against patterns, extracting information from an enum or a structure and defining specific operations for specific value combination.

```haxe
var a = {foo: 12};
switch a {
  case {foo: i}: trace(i);
  default:
}
```

**[Properties](class-field-property):**

Variable class fields can be designed as properties with custom read and write access, allowing fine grained access control.

```haxe
public var color(get,set);
function get_color() {
  return element.style.backgroundColor;
}
function set_color(c:String) {
  trace('Setting background of element to $c');
  return element.style.backgroundColor = c;
}
```

**[Access control](lf-access-control):**

The access control language feature uses the Haxe metadata syntax to force or allow access classes or fields.

**[Type Parameters, Constraints and Variance](type-system-type-parameters):**

Types can be parametrized with type parameters, allowing typed containers and other complex data structures. Type parameters can also be constrained to certain types and respect variance rules.

```haxe
class Main<A> {
  static function main() {
    new Main<String>("foo");
    new Main(12); // use type inference
  }

  function new(a:A) {}
}
```

<!--label:lf-condition-compilation-->
### Conditional Compilation

Haxe allows conditional compilation by using `#if`, `#elseif` and(及|gate) `#else` and(及|gate) checking for(或|gate) **compiler(編譯器|) flags**.

> ##### define(定義|): compiler(編譯器|) Flag
>
> A compiler(編譯器|) flag is a configurable value(值|) which may influence the compilation(編譯|名詞) process(處理|). Such a flag can be set by invoking the command(及|gate) line(列|) with `-D key=value` or(或|gate) just `-D key`, in which case the value defaults to `"1"`. The compiler also sets several flags internally to pass information between different compilation steps.

This example demonstrates usage of conditional compilation:

<!-- [code asset](assets/ConditionalCompilation.hx) -->
```haxe
class Main {
  public static function main() {
    #if !debug
    trace("ok");
    #elseif (debug_level > 3)
    trace(3);
    #else
    trace("debug level too low");
    #end
  }
}
```

Compiling this without any flags will leave only the `trace("ok");` line(列|) in the body(本體|) of the `main` method(方法|). The other branches are discarded while parsing the file. These other branches must still contain valid(有效|) Haxe syntax(語法|), but the code is not(非|gate) type-check(型式檢查|)ed.

The condition(條件|)s after(後於|) `#if` and(及|gate) `#elseif` allow(容許|又：允許) the following expression(運算式|)s:

* any(任意|) identifier(識別符|) is replaced by the value(值|) of the compiler(編譯器|) flag by the same name(名稱|). not(非|gate)e that `-D some-flag` from command(及|gate) line(列|) leads to the flags `some-flag` and(及|gate) `some_flag` to be define(定義|)d.
* The value(值|)s of `String`, `Int` and(及|gate) `Float` constant(常數|)s are used directly.
* The boolean(布林|) operator(運算子|)s `&&` (and(及|gate)), <code>&#124;&#124;</code> (or(或|gate)) and(及|gate) `!` (not(非|gate)) wor(或|gate)k as expected, however the full expression(運算式|) must be completely contained by parentheses.
* The operator(運算子|)s `==`, `!=`, `>`, `>=`, `<`, `<=` can be used to compare value(值|)s.
* Parentheses `()` can be used to group expression(運算式|)s as usual.

The Haxe parser(剖析器|) does not(非|gate) parse `some-flag` as a single token and(及|gate) instead read(讀出|)s it as a subtraction(減法|) binary operator(運算子|) `some - flag`. In cases like this the underscore version `some_flag` has to be used.

##### Wor(或|gate)king with compiler(編譯器|) flags

compiler(編譯器|) flags are available at compile time, the following method(方法|)s only wor(或|gate)k in macro(巨集|) context:

* To see if a compiler(編譯器|) flag is set, use `haxe.macro.Context.defined("any_flag")`.
* To get the value of a compiler flag, use `haxe.macro.Context.definedValue("any_flag")`.
* To get a map of all compiler flags with its value use `haxe.macro.Context.getDefines()`.

##### Haxelibs

By default, each used haxelib version is automatically added as flag, e.g. when you add `-L actuate`, the compiler adds `-D actuate=1.8.7`. To test if a library exists in current context, use `#if actuate`. To check a specific haxelib version, use the operators, for example `#if (actuate <= "1.8.7")`

##### Built-in Compiler Flags

An exhaustive list of all built-in defines can be obtained by invoking the Haxe Compiler with the `--help-defines` argument(引數|). The Haxe compiler(編譯器|) allow(容許|又：允許)s multiple `-D` flags per compilation(編譯|名詞).

##### Related content

* See also the [compiler(編譯器|) Flags list(列表|)](compiler-usage-flags).

<!--label:lf-target-defines-->
#### target(目標|) define(定義|)s

Depending on the current target(目標|), at least one of the following flags will be define(定義|)d. not(非|gate)e that they are the same as the [argument(引數|) provided to the compiler(編譯器|) to specify the output](compiler-usage).

* `cpp` define(定義|)d when generating C++ code or(或|gate) a cppia script.
* `cppia` define(定義|)d when generating a cppia script.
* `cs` define(定義|)d when generating C# code.
* `eval` define(定義|)d when running the code with `--interp`, or when running in a macro context.
* `hl` define(定義|)d when generating HashLink code.
* `java` define(定義|)d when generating Java or(或|gate) JVM code.
* `js` define(定義|)d when generating JavaScript code.
* `lua` define(定義|)d when generating Lua code.
* `neko` define(定義|)d when generating a Neko binary.
* `php` define(定義|)d when generating PHP code.
* `python` define(定義|)d when generating Python code.
* `swf` define(定義|)d when generating a SWF file.

additional(附加|)ly, parts of code may be used in a macro(巨集|) context or(或|gate) during display completion. These flags can be used to check if this is the case:

* `display` define(定義|)d when providing code completion.
* `macro` define(定義|)d in a macro(巨集|) context.

##### Suppor(或|gate)ted feature(特徵|)s

* `sys` define(定義|)d if the target(目標|) suppor(或|gate)ts the [sys API](std-sys).

##### since Haxe 4.0.0

To provide mor(或|gate)e fine-grained(細緻|) knowledge about the feature(特徵|)s suppor(或|gate)ted on the current target(目標|) without having to manual(手冊/手動|n./adj.)ly check which target(目標|) suppor(或|gate)ts what, Haxe 4 provides the `target.*` define(定義|)s:

* `target.static` (or(或|gate) `static`) Defined if the target is [static](types-nullability).
* `target.sys` (or(或|gate) `sys` as not(非|gate)ed above) define(定義|)d if the target(目標|) suppor(或|gate)ts the [sys API](std-sys).
* `target.utf16` (or(或|gate) `utf16`) Defined if the target uses UTF-16 for its [internal string representation](std-String).
* `target.threaded` define(定義|)d if the target(目標|) suppor(或|gate)ts the unified [thread(讀出|)ing API](std-threading).
* `target.name` define(定義|)d to be the name(名稱|) of the target(目標|), e.g. `js`.

<!--label:lf-target-specific-files-->
#### Target-Specific Files

##### since Haxe 4.0.0

In addition to surrounding individual pieces of code with compile-time checks, it is possible to provide completely separate target-specific module alternatives to the compiler. This feature works as follows:

* When the compiler finds the file `<Module>.hx`, it then checks the containing directory for a file called `<Module>.<target>.hx`, where `<target>` is the [name(名稱|) of the current target(目標|)](lf-target-defines).
* The main file for(或|gate) the module(模組|) (without a target(目標|)-specific(特定|) extension(延伸|)) must exist.
* If a target(目標|)-specific(特定|) file is found for(或|gate) the module(模組|), the main file is not(非|gate) loaded at all. Keep in mind that this means error(錯誤|)s are not(非|gate) checked in the main file.

As an example, we can have the following director(或|gate)y structure(結構|):

```haxe
/somepackage/Example.hx
/somepackage/Example.js.hx
/Main.hx
```

In `Main.hx` we can use `somepackage.Example` module(模組|). This module(模組|) is define(定義|)d in the file `somepackage/Example.hx`. However, if we compile for JavaScript, the module is instead defined in the file `somepackage/Example.js.hx`.

<!--label:lf-externs-->
### Externs

Externs can be used to describe target-specific interaction in a type-safe manner. They are defined like normal classes, except that

* the `class` keyword(關鍵字|) is preceded by the `extern` keyword(關鍵字|),
* [method(方法|)s](class-field-method) have no expression(運算式|)s,
* all argument(引數|) and(及|gate) return(回傳|) type(型式/型式化|n./v. 又：型別)s are explicit(明確|), and(及|gate)
* the default(預設|) [visibility(可見性|)](class-field-visibility) is `public` (`private` must be specified explicitly(明確|)).

A common example from the [Haxe standard library(標準函式庫|)](std) is the `Math` class(類別|), as an excerpt shows:

```haxe
extern class Math {
  static var PI(default,null):Float;
  static function floor(v:Float):Int;
}
```

We see that externs can define both methods and variables (actually, `PI` is declare(宣告|)d as a read-only(唯讀|) [property(屬性|)](class-field-property)). Once this infor(或|gate)mation is available to the compiler(編譯器|), it allow(容許|又：允許)s field(欄位|) access(存取|) accor(或|gate)dingly and(及|gate) also knows the type(型式/型式化|n./v. 又：型別)s:

<!-- [code asset](assets/Extern.hx) -->
```haxe
class Main {
  static public function main() {
    var pi = Math.floor(Math.PI);
    $type(pi); // Int
  }
}
```

This wor(或|gate)ks because the return(回傳|) type(型式/型式化|n./v. 又：型別) of method(方法|) `floor` is declare(宣告|)d to be `Int`.

The Haxe Standard Library comes with many externs for the Flash and JavaScript target. They allow accessing the native APIs in a type-safe manner and are instrumental for designing higher-level APIs. There are also externs for many popular native libraries on [haxelib](haxelib).

The Flash, Java and C# targets allow direct inclusion of native libraries from [command line](compiler-usage). Target-specific details are explained in the respective sections of [Target Details](target-details).

Some targets such as Python or JavaScript may require generating additional "import" code that loads an `extern` class(類別|) from a native(原生|) module(模組|). Haxe provides ways to declare(宣告|) such dependencies also describe(描述|)d in respective sections [target(目標|) Details](target-details).

##### Rest argument(引數|)s and(及|gate) type(型式/型式化|n./v. 又：型別) choices
##### since Haxe 3.2.0

The haxe.extern(外部|) package(套件|) provides two type(型式/型式化|n./v. 又：型別)s that help map(映射|)ping native(原生|) semantic(語意|)s to Haxe:

* `Rest<T>`: This type can be used as a final function argument to allow passing an arbitrary number of additional call arguments. The type parameter can be used to constrain these arguments to a specific type.
* `EitherType<T1,T2>`: This type allows using either of its parameter types, thus representing a type choice. It can be nested to allow more than two different types.

We demonstrate the usage in this code sample:

<!-- [code asset](assets/RestAndEitherType.hx) -->
```haxe
import haxe.extern.Rest;
import haxe.extern.EitherType;

extern class MyExtern {
  static function f1(s:String, r:Rest<Int>):Void;
  static function f2(e:EitherType<Int, String>):Void;
}

class Main {
  static function main() {
    MyExtern.f1("foo", 1, 2, 3); // use 1, 2, 3 as rest argument
    MyExtern.f1("foo"); // no rest argument
    // MyExtern.f1("foo", "bar"); // String should be Int

    MyExtern.f2("foo");
    MyExtern.f2(12);
    // MyExtern.f2(true); // Bool should be EitherType<Int, String>
  }
}
```

##### Visibility

Externs support the `private` visibility(可見性|) modifier(修飾符|). However, because the default(預設|) visibility(可見性|) in an extern(外部|) class(類別|) is `public`, `private` needs to be explicitly(明確|) specified.

Specifying `private` member(成員|)s is helpful when an API intends to allow(容許|又：允許) overriding function(函式|)s. Also, Haxe cannot(非|gate) prevent subclass(類別|)es from reusing field(欄位|) name(名稱|)s unless if the field(欄位|)s are included in the extern(外部|) definition(定義|). This is import(匯入|)ant on target(目標|)s such as JavaScript where reusing a super class(類別|)’s field(欄位|) name(名稱|) as a new field(欄位|) in a subclass(類別|) is not(非|gate) suppor(或|gate)ted.

```haxe
extern class ExampleSuperClass {
  // Require subclassing to use
  private function new();

  // Only allow subclasses access to this overridable function
  private function overridableFunction():String;

  // This function is implicitly public
  function doSomething():String;
}
```

<!--label:lf-externs-native-->
#### Native Metadata

When creating externs it is possible that certain fields will conflict with Haxe keywords, even though they are valid identifiers for the given target. These problems can be resolved by marking the conflicting fields with the metadata `:native`, with the intended identifier provided as a parameter.

<!-- [code asset](assets/ExternNative.hx) -->
```haxe
extern class A {
  public function new();
  @:native("final") var final_:Int;
}

class Main {
  public static function main():Void {
    var a = new A();
    a.final_ = 3;
  }
}
```

The generated JavaScript output shows that we are actually assigning to the `final` field(欄位|):

```haxe
(function ($global) { "use strict";
var Test = function() { };
Test.main = function() {
  new A().final = 3;
};
Test.main();
})({});
```

This metadata can be applied to class and interface fields, but not the fields of a structure type.

<!--label:types-dynamic-implemented-->
#### Implementing Dynamic

Extern classes can [implement](types-interfaces) `Dynamic` and(及|gate) `Dynamic<T>` which enables arbitrary(任意|) field(欄位|) access(存取|). In the for(或|gate)mer case, field(欄位|)s can have any(任意|) type(型式/型式化|n./v. 又：型別), in the latter, they are constrained to be compatible(相容|) with the parameter(參數|) type(型式/型式化|n./v. 又：型別):

<!-- [code asset](assets/ImplementsDynamic.hx) -->
```haxe
extern class ImplementsDynamic implements Dynamic<String> {
  public var present:Int;
  public function new();
}

class Main {
  static public function main() {
    var c = new ImplementsDynamic();
    // valid, present is an existing field
    c.present = 1;
    // valid, assigned value is a String
    c.stringField = "foo";
    // error, Int should be String
    // c.intField = 1;
  }
}
```

implement(實作|)ing `Dynamic` does not(非|gate) satisfy the requirements of other implement(實作|)ed interface(介面|)s. The expected field(欄位|)s still have to be implement(實作|)ed explicitly(明確|).

> ##### Trivia: implement(實作|)ing `Dynamic` on non-extern(外部|)s
>
> Starting with Haxe 4, implement(實作|)ing `Dynamic` is only allow(容許|又：允許)ed on extern(外部|) class(類別|)es. In previous versions any(任意|) class(類別|) could implement(實作|) `Dynamic`, allowing arbitrary fields to be read or written. Additionally a special `resolve` method(方法|) could be used to resolve(解析|) read(讀出|) access(存取|) to a non-existend field(欄位|). A similar feature(特徵|) is now available as field(欄位|) access(存取|) [operator(運算子|) overload(多載|)](types-abstract-operator-overloading) on abstract(抽象|)s.

<!--label:lf-static-extension-->
### static(靜態|) extension(延伸|)

> ##### define(定義|): static(靜態|) extension(延伸|)
>
> A static(靜態|) extension(延伸|) allow(容許|又：允許)s pseudo-extend(擴充|又：延伸)ing existing type(型式/型式化|n./v. 又：型別)s without modifying their source. In Haxe this is achieve(達成|)d by declaring a static(靜態|) method(方法|) with a first argument(引數|) of the extend(擴充|又：延伸)ing type(型式/型式化|n./v. 又：型別) and(及|gate) then bringing the defining class(類別|) into context through `using`.

Static extensions can be a powerful tool which allows augmenting types without actually changing them. The following example demonstrates the usage:

<!-- [code asset](assets/StaticExtension.hx) -->
```haxe
using Main.IntExtender;

class IntExtender {
  static public function triple(i:Int) {
    return i * 3;
  }
}

class Main {
  static public function main() {
    trace(12.triple());
  }
}
```

Clearly, `Int` does not(非|gate) native(原生|)ly provide a `triple` method(方法|), yet this program compiles and(及|gate) outputs `36` as expected. This is because the call(呼叫|) to `12.triple()` is transfor(或|gate)med into `IntExtender.triple(12)`. There are three requirements for this:

1. Both the literal `12` and(及|gate) the first argument(引數|) of `triple` are known to be of type(型式/型式化|n./v. 又：型別) `Int`.
2. The class `IntExtender` is brought into context through `using Main.IntExtender`.
3. `Int` does not(非|gate) have a `triple` field(欄位|) by itself (if it had, that field(欄位|) would take priority(優先權|) over the static(靜態|) extension(延伸|)).

static(靜態|) extension(延伸|)s are usually considered syntactic sugar and(及|gate) indeed they are, but it is wor(或|gate)th not(非|gate)ing that they can have a dramatic effect on code read(讀出|)ability: Instead of nested(巢套|) call(呼叫|)s in the for(或|gate)m of `f1(f2(f3(f4(x))))`, chained calls in the form of `x.f4().f3().f2().f1()` can be used.

Following the rules previously describe(描述|)d in [resolution(解析|) or(或|gate)der](type-system-resolution-order), multiple `using` expression(運算式|)s are checked from bottom to top(自底向頂|), with the type(型式/型式化|n./v. 又：型別)s within each module(模組|) as well as the field(欄位|)s within each type(型式/型式化|n./v. 又：型別) being checked from top to bottom(自頂向底|). Using a module(模組|) (as opposed to a specific(特定|) type(型式/型式化|n./v. 又：型別) of a module(模組|), see [module(模組|)s and(及|gate) path(路徑|)s](type-system-modules-and-paths)) as static(靜態|) extension(延伸|) brings all its type(型式/型式化|n./v. 又：型別)s into context.

The static(靜態|) extension(延伸|) keyword(關鍵字|) `using` also implies the effects of an [`import`](type-system-import) of the same module.

##### Related content

* [Haxe snippets and tutorials about static extensions](http://code.haxe.org/tag/static-extension.html) in the Haxe Code Cookbook.

<!--label:lf-static-extension-in-std-->
#### In the Haxe Standard Library

Several classes in the Haxe Standard Library are suitable for static extension usage. The next example shows the usage of `StringTools`:

<!-- [code asset](assets/StaticExtension2.hx) -->
```haxe
using StringTools;

class Main {
  static public function main() {
    "adc".replace("d", "b");
  }
}
```

While `String` does not(非|gate) have a `replace` functionality(功能|) by itself, the `using StringTools` static(靜態|) extension(延伸|) provides one. As usual, the JavaScript output nicely shows the transfor(或|gate)mation:

```js
Main.main = function() {
  StringTools.replace("adc","d","b");
}
```

The following classes from the Haxe Standard Library are designed to be used as static extensions:

* [StringTools](https://api.haxe.org/StringTools.html): Provides extended functionality on strings, such as replacing or trimming.
* [Lambda](https://api.haxe.org/Lambda.html): Provides functional methods on iterables.
* [haxe.EnumTools](https://api.haxe.org/haxe/EnumTools.html): Provides type information functionality on enums and their instances.
* `haxe.macro.Tools`: Provides different extensions for working with macros (see [Tools](macro-tools)).

> ##### Trivia: "using" using
>
> Since the `using` keyword(關鍵字|) was added to the language, it has been common to talk about certain problems with "using using" or(或|gate) the effect of "using using". This makes for(或|gate) awkward English in many(任意|) cases, so the author(或|gate) of this manual(手冊/手動|n./adj.) decided to call(呼叫|) the feature(特徵|) by what it actually is: static(靜態|) extension(延伸|).

<!--label:lf-static-extension-metadata-->
#### static(靜態|) extension(延伸|) metadata(元資料|)

##### since Haxe 4.0.0

##### Exclusion from static(靜態|) extension(延伸|)

By default(預設|), using a class(類別|) as a static(靜態|) extension(延伸|) brings all of its static(靜態|) method(方法|)s into the context, allow(容許|又：允許)ing them to be used as extension(延伸|)s of the appropriate type(型式/型式化|n./v. 又：型別)s. In certain situations, the class(類別|) can provide other static(靜態|) method(方法|)s which are not(非|gate) intended for(或|gate) static(靜態|) extension(延伸|). To make sure they do not(非|gate) interfere with the proper method(方法|)s of the type(型式/型式化|n./v. 又：型別), these method(方法|)s can be marked with `@:noUsing`:

<!-- [code asset](assets/StaticExtension3.hx) -->
```haxe
using Main.IntExtender;

class IntExtender {
  @:noUsing static public function double(i:Int) {
    return i * 2;
  }

  static public function triple(i:Int) {
    return i * 3;
  }
}

class Main {
  static public function main() {
    // works:
    trace(12.triple());
    // does not work because the method is marked with @:noUsing:
    // trace(12.double());
    // works as a normal static method:
    trace(IntExtender.double(12));
  }
}
```

##### Default Static Extension

It is also possible to always enable particular static extensions for a given type, by annotating the type with the `@:using(args...)` metadata(元資料|). The argument(引數|)s are the full dot path(路徑|)s of static(靜態|) extension(延伸|) class(類別|)es that will be applied on the type(型式/型式化|n./v. 又：型別):

<!-- [code asset](assets/StaticExtension4.hx) -->
```haxe
@:using(Main.TreeTools)
enum Tree {
  Node(l:Tree, r:Tree);
  Leaf(value:Int);
}

class TreeTools {
  public static function sum(tree:Tree):Int {
    return (switch (tree) {
      case Node(l, r): sum(l) + sum(r);
      case Leaf(value): value;
    });
  }
}

class Main {
  static public function main() {
    var a = Node(Node(Leaf(1), Leaf(2)), Leaf(3));
    // works, even though there was no 'using Main.TreeTools' in this module
    trace(a.sum());
  }
}
```

<!--label:lf-pattern-matching-->
### pattern matching(模式匹配|)

<!--subtoc-->

<!--label:lf-pattern-matching-introduction-->
#### Introduction

pattern matching(模式匹配|) is the process(處理|) of branching depending on a value(值|) match(匹配|)ing given, possibly deep patterns. In Haxe, pattern matching(模式匹配|) is primarily done within [`switch` expression(運算式|)s](expression(運算式|)-switch) where the individual `case` expression(運算式|)s represent(表述|) the patterns. Here we will explor(或|gate)e the syntax(語法|) for(或|gate) different patterns using this data structure(資料結構|) as running example:

<!-- [code asset](assets/Tree.hx) -->
```haxe
enum Tree<T> {
  Leaf(v:T);
  Node(l:Tree<T>, r:Tree<T>);
}
```

Some pattern match(匹配|)er basics include:

* Patterns will always be match(匹配|)ed from top to bottom(自頂向底|).
* The topmost pattern that match(匹配|)es the input value(值|) has its expression(運算式|) execute(執行|)d.
* A `_` pattern match(匹配|)es any(任意|)thing, so `case _`: is equal to `default:`

##### Related content

* More about the [switch expression](expression-switch).
* [Haxe snippets and tutorials about pattern matching](http://code.haxe.org/tag/pattern-matching.html) in the Haxe Code Cookbook.

<!--label:lf-pattern-matching-enums-->
#### Enum matching

Enums can be matched by their constructors in a natural way:

<!-- [code asset](assets/PatternMatching1.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
var match = switch (myTree) {
    // matches any Leaf
    case Leaf(_): "0";
    // matches any Node that has r = Leaf
    case Node(_, Leaf(_)): "1";
    // matches any Node that has
    // r = another Node, which has
    // l = Leaf("bar")
    case Node(_, Node(Leaf("bar"), _)): "2";
    // matches anything
    case _: "3";
  }
trace(match); // 2
```

The pattern matcher will check each case from top to bottom and pick the first one that matches the input value. The following manual interpretation of each case rule helps understanding the process:

* `case Leaf(_)`: matching fails because `myTree` is a `Node`
* `case Node(_, Leaf(_))`: matching fails because the right sub-tree of `myTree` is not(非|gate) a `Leaf`, but another `Node`
* `case Node(_, Node(Leaf("bar"), _))`: matching succeeds
* `case _`: this is not checked here because the previous line matched

<!--label:lf-pattern-matching-variable-capture-->
#### Variable capture

It is possible to catch any value of a sub-pattern by matching it against an identifier:

<!-- [code asset](assets/PatternMatching2.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
var name = switch (myTree) {
    case Leaf(s): s;
    case Node(Leaf(s), _): s;
    case _: "none";
  }
trace(name); // foo
```

This would return one of the following:

* If `myTree` is a `Leaf`, its name is returned.
* If `myTree` is a `Node` whose left sub-tree is a `Leaf`, its name is returned (this will apply here, returning `"foo"`).
* Otherwise `"none"` is return(回傳|)ed.

It is also possible to use `=` to capture value(值|)s which are further match(匹配|)ed:

<!-- [code asset](assets/PatternMatching3.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
var node = switch (myTree) {
    case Node(leafNode = Leaf("foo"), _): leafNode;
    case x: x;
  }
trace(node); // Leaf(foo)
```

Here, `leafNode` is bound(繫結|) to `Leaf("foo")` if the input match(匹配|)es that. In all other cases, `myTree` itself is return(回傳|)ed: `case x` wor(或|gate)ks similar to `case _` in that it match(匹配|)es any(任意|)thing, but with an identifier(識別符|) name(名稱|) like `x` it also bind(繫結|)s the match(匹配|)ed value(值|) to that variable(變數|).

##### since Haxe 4.0.0

If the compiler(編譯器|) detects that the name(名稱|) of a "catch(捕捉|)-all" variable(變數|) is very similar to an enum(枚舉|) constructor(建構式|), it will warn about a potential typo. This can be avoided by prefix(前綴|又：前置)ing the variable(變數|) identifier(識別符|) with `var`:

<!-- [code asset](assets/PatternMatching4.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
switch (myTree) {
  case Leaf(_):
  // ...
  case var node:
    // without var above the compiler would warn about a potential typo
    // node contains the entire matched tree
}
```

Any capture variable can be prefixed with `var`, even within sub-patterns.

<!--label:lf-pattern-matching-structure-->
#### Structure matching

It is also possible to match against the fields of anonymous structures and instances:

<!-- [code asset](assets/PatternMatching5.hx) -->
```haxe
var myStructure = {
  name: "haxe",
  rating: "awesome"
};
var value = switch (myStructure) {
    case {name: "haxe", rating: "poor"}:
      throw false;
    case {rating: "awesome", name: n}:
      n;
    case _:
      "no awesome language found";
  }
trace(value); // haxe
```

In the second case we bind the matched `name` field(欄位|) to identifier(識別符|) `n` if `rating` match(匹配|)es `"awesome"`. Of course this structure could also be put into the `Tree` from the previous example to combine structure(結構|) and(及|gate) enum(枚舉|) match(匹配|)ing.

<!--label:lf-pattern-matching-array-->
#### array(陣列|) match(匹配|)ing

array(陣列|)s can be match(匹配|)ed on fixed length:

<!-- [code asset](assets/PatternMatching6.hx) -->
```haxe
var myArray = [1, 6];

var match = switch (myArray) {
    case [2, _]: "0";
    case [_, 6]: "1";
    case []: "2";
    case [_, _, _]: "3";
    case _: "4";
  }
trace(match); // 1
```

This will trace `1` because `myArray[1]` match(匹配|)es `6`, and `myArray[0]` is allow(容許|又：允許)ed to be any(任意|)thing.

<!--label:lf-pattern-matching-or-->
#### or(或|gate) patterns

The <code>&#124;</code> operator(運算子|) can be used any(任意|)where within patterns to describe(描述|) multiple accepted patterns:

<!-- [code asset](assets/PatternMatching7.hx) -->
```haxe
var match = switch (7) {
    case 4 | 1: "0";
    case 6 | 7: "1";
    case _: "2";
  }
trace(match); // 1
```

If there is a captured variable(變數|) in an or(或|gate)-pattern, it must appear in both its sub-patterns.

<!--label:lf-pattern-matching-guards-->
#### Guards

It is also possible to further restrict patterns with the `case ... if (condition):` syntax(語法|):

<!-- [code asset](assets/PatternMatching8.hx) -->
```haxe
var myArray = [7, 6];
var s = switch (myArray) {
    case [a, b] if (b > a):
      b + ">" + a;
    case [a, b]:
      b + "<=" + a;
    case _: "found something else";
  }
trace(s); // 6<=7
```

The first case has an additional(附加|) guard condition(條件|) `if (b > a)`. It will only be selected if that condition holds, otherwise matching continues with the next case.

<!--label:lf-pattern-matching-tuples-->
#### Match on multiple values

Array syntax can be used to match on multiple values:

<!-- [code asset](assets/PatternMatching9.hx) -->
```haxe
var s = switch [1, false, "foo"] {
    case [1, false, "bar"]: "0";
    case [_, true, _]: "1";
    case [_, false, _]: "2";
  }
trace(s); // 2
```

This is quite similar to usual array matching, but there are differences:

* The number of elements is fixed, so patterns of different array length will not be accepted.
* It is not possible to capture the switch value in a variable, i.e. `case x` is not(非|gate) allow(容許|又：允許)ed (`case _` still is).

<!--label:lf-pattern-matching-extractors-->
#### extract(擷取|又：抽取)or(或|gate)s

##### since Haxe 3.1.0

extract(擷取|又：抽取)or(或|gate)s allow(容許|又：允許) apply(套用|)ing transfor(或|gate)mations to value(值|)s being match(匹配|)ed. This is often useful when a small operation(運算|) is required on a match(匹配|)ed value(值|) before(前於|) match(匹配|)ing can continue:

<!-- [code asset](assets/Extractor2.hx) -->
```haxe
enum Test {
  TString(s:String);
  TInt(i:Int);
}

class Main {
  static public function main() {
    var e = TString("fOo");
    switch (e) {
      case TString(temp):
        switch (temp.toLowerCase()) {
          case "foo": true;
          case _: false;
        }
      case _:
        false;
    }
  }
}
```

Here we have to capture the argument(引數|) value(值|) of the `TString` enum(枚舉|) constructor(建構式|) in a variable(變數|) `temp` and(及|gate) use a nested(巢套|) switch on `temp.toLowerCase()`. Obviously, we want matching to succeed if `TString` hold(儲存|TODO:又：存儲)s a value(值|) of `"foo"` regardless of its casing. This can be simplified with extract(擷取|又：抽取)or(或|gate)s:

<!-- [code asset](assets/Extractor.hx) -->
```haxe
enum Test {
  TString(s:String);
  TInt(i:Int);
}

class Main {
  static public function main() {
    var e = TString("fOo");
    var success = switch(e) {
      case TString(_.toLowerCase() => "foo"):
        true;
      case _:
        false;
    }
  }
}
```

extract(擷取|又：抽取)or(或|gate)s are identified by the `extractorExpression => match` expression(運算式|). The compiler(編譯器|) generate(產生|)s code which is similar to the previous example, but the or(或|gate)iginal syntax(語法|) was greatly simplified. extract(擷取|又：抽取)or(或|gate)s consist of two parts, which are separated(分隔|) by the `=>` operator(運算子|):

1. The left side can be any(任意|) expression(運算式|), where all occurrences of underscore(底線|) `_` are replaced with the currently match(匹配|)ed value(值|).
2. The right side is a pattern which is match(匹配|)ed against the result of the evaluation of the left side.

Since the right side is a pattern, it can contain anot(非|gate)her extract(擷取|又：抽取)or(或|gate). The following example "chains" two extract(擷取|又：抽取)or(或|gate)s:

<!-- [code asset](assets/Extractor4.hx) -->
```haxe
class Main {
  static public function main() {
    switch (3) {
      case add(_, 1) => mul(_, 3) => a:
        trace(a);
    }
  }

  static function add(i1:Int, i2:Int) {
    return i1 + i2;
  }

  static function mul(i1:Int, i2:Int) {
    return i1 * i2;
  }
}
```

This traces `12` as a result of the call(呼叫|)s to `add(3, 1)`, where `3` is the match(匹配|)ed value(值|), and(及|gate) `mul(4, 3)` where `4` is the result of the `add` call(呼叫|). It is wor(或|gate)th not(非|gate)ing that the `a` on the right side of the second `=>` operator(運算子|) is a [capture variable(變數|)](lf-pattern-matching-variable-capture).

It is currently not(非|gate) possible to use extract(擷取|又：抽取)or(或|gate)s within [or(或|gate)-patterns](lf-pattern-match(匹配|)ing-or(或|gate)):

<!-- [code asset](assets/Extractor5.hx) -->
```haxe
class Main {
  static public function main() {
    switch ("foo") {
      // Extractors in or patterns are not allowed
      case(_.toLowerCase() => "foo") | "bar":
    }
  }
}
```

However, it is possible to have or(或|gate)-patterns on the right side of an extract(擷取|又：抽取)or(或|gate), so the previous example would compile without the parentheses.

<!--label:lf-pattern-matching-exhaustiveness-->
#### exhaustiveness(完整性|TODO:) checks

The compiler(編譯器|) ensures that no possible cases are for(或|gate)gotten:

```haxe
switch (true) {
    case false:
} // Unmatched patterns: true
```

The matched type `Bool` admits two value(值|)s `true` and(及|gate) `false`, but only `false` is checked.

exhaustiveness(完整性|TODO:) is not(非|gate) checked when match(匹配|)ing on `Int`, `Float` or(或|gate) `String` if no value(值|) from the switch is required, which means that it appears at block(塊段|)-level.

<!--label:lf-pattern-matching-unused-->
#### Useless pattern checks

In a similar fashion, the compiler(編譯器|) detects patterns which will never match(匹配|) the input value(值|):

```haxe
switch (Leaf("foo")) {
    case Leaf(_)
       | Leaf("foo"): // This pattern is unused
    case Node(l,r):
    case _: // This pattern is unused
}
```

<!--label:lf-pattern-matching-single-->
#### Single pattern check

The compiler provides the function `match` to check if an enum(枚舉|) value(值|) match(匹配|)es a given pattern:

<!-- [code asset](assets/PatternMatching10.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
trace(myTree.match(Leaf(_))); // false
trace(myTree.match(Node(_) | Leaf(_))); // true
trace(myTree.match(Node(Leaf("foo"), _))); // true
```

As this function(函式|) only tests if the pattern is match(匹配|)ed, guards and(及|gate) variable(變數|) capture are unavailable.

The `match` function(函式|) is equivalent to a `switch` with a single `case` for(或|gate) the given pattern, return(回傳|)ing `true`, and a `default` return(回傳|)ing `false`.

<!-- [code asset](assets/PatternMatching11.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
myTree.match(Node(_));
// is equivalent to
switch (myTree) {
  case Node(_):
    true;
  case _:
    false;
}
```

See the [EnumValue API documentation (since Haxe 3.2.1)](https://api.haxe.org/haxe/EnumValueTools.html#match) for more information.

<!--label:lf-string-interpolation-->
### String Interpolation

With Haxe 3 it is no longer necessary to manually concatenate parts of a string due to the introduction of **String Interpolation**. Special identifiers, denoted by the dollar sign `$` within a string(字串|) enclosed(括住|) by single-quote `'` characters, are evaluate(評估|)d as if they were concatenated identifier(識別符|)s:

```haxe
var x = 12;
// The value of x is 12
trace('The value of x is $x');
```

Furthermore, it is possible to include whole expressions in the string by using `${expr}`, with `expr` being any(任意|) valid(有效|) Haxe expression(運算式|):

```haxe
var x = 12;
// The sum of 12 and 3 is 15
trace('The sum of $x and 3 is ${x + 3}');
```

String interpolation is a compile-time feature and has no impact on the runtime. The above example is equivalent to manual concatenation, which is exactly what the compiler generates:

```haxe
trace("The sum of " + x + " and 3 is " + (x + 3));
```

Of course the use of single-quote enclosed strings without any interpolation remains valid, but care has to be taken regarding the $ character as it triggers interpolation. If an actual dollar-sign should be used in the string, `$$` can be used.

> ##### Trivia: string interpolation(字串插值|) before(前於|) Haxe 3
>
> string interpolation(字串插值|) has been a Haxe feature(特徵|) since version 2.09. Back then, the macro(巨集|) `Std.format` had to be used, being both slower and(及|gate) less comfor(或|gate)table than the new string interpolation(字串插值|) syntax(語法|).

<!--label:lf-array-comprehension-->
### array(陣列|) comprehension(理解|)

array(陣列|) comprehension(理解|) in Haxe combines [array(陣列|) declaration(宣告|)](expression-array-declaration) and(及|gate) loop(迴圈|又：循環)s to allow(容許|又：允許) concise initialization(初始化|) of array(陣列|)s. It is identified by [`for`](expression-for) or [`while`](expression-while) constructs:

<!-- [code asset](assets/ArrayComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [for (i in 0...10) i];
    trace(a); // [0,1,2,3,4,5,6,7,8,9]

    var i = 0;
    var b = [while (i < 10) i++];
    trace(b); // [0,1,2,3,4,5,6,7,8,9]
  }
}
```

Variable `a` is initialize(初始化|)d to an array(陣列|) hold(儲存|TODO:又：存儲)ing the numbers 0 to 9. The compiler(編譯器|) generate(產生|)s code which adds the value(值|) of each loop(迴圈|又：循環) iteration(疊代|) to the array(陣列|), so the following code would be equivalent:

```haxe
var a = [];
for (i in 0...10) a.push(i);
```

Variable `b` is initialize(初始化|)d to an array(陣列|) with the same value(值|)s, but through a different comprehension(理解|) style using `while` instead of `for`. Again, the following code would be equivalent:

```haxe
var i = 0;
var b = [];
while(i < 10) b.push(i++);
```

The loop expression can be anything, including conditions and nested loops, so the following works as expected:

<!-- [code asset](assets/AdvArrayComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [
      for (a in 1...11)
        for (b in 2...4)
          if (a % b == 0)
            a + "/" + b
    ];
    // [2/2,3/3,4/2,6/2,6/3,8/2,9/3,10/2]
    trace(a);
  }
}
```

<!--label:lf-map-comprehension-->
### Map Comprehension

Map comprehension in Haxe is similar to array comprehension, but just like [map declaration](expression-map-declaration), it additionally uses the `=>` operator(運算子|):

<!-- [code asset](assets/MapComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [for (i in 0...5) i => 'number ${i}'];
    trace(a); // {0 => number 0, 1 => number 1, 2 => number 2, 3 => number 3, 4 => number 4}

    var i = 0;
    var b = [while (i < 5) i => 'number ${i++}'];
    trace(b); // {0 => number 0, 1 => number 1, 2 => number 2, 3 => number 3, 4 => number 4}
  }
}
```

variable(變數|) `a` is initialize(初始化|)d to an `Map` hold(儲存|TODO:又：存儲)ing keys from 0 to 4 and(及|gate) string(字串|) value(值|)s. The compiler(編譯器|) generate(產生|)s code which adds the value(值|) of each loop(迴圈|又：循環) iteration(疊代|) to the map(映射|), so the following code would be equivalent:

```haxe
var a = new Map();
for (i in 0...5) a.set(i, 'number ${i}');
```

Variable `b` is initialize(初始化|)d to an `Map` with the same keys and(及|gate) value(值|)s, but through a different comprehension(理解|) style using `while` instead of `for`. Again, the following code would be equivalent:

```haxe
var i = 0;
var b = new Map();
while(i < 5) b.set(i, 'number ${i++}');
```

The loop expression can be anything, including conditions and nested loops, so the following works as expected:

<!-- [code asset](assets/AdvMapComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [
      for (x in 0...5)
        for (y in 0...5)
          if (x != y)
            x => y
    ];
    // {0 => 4, 1 => 4, 2 => 4, 3 => 4, 4 => 3}
    trace(a);
  }
}
```

<!--label:lf-iterators-->
### Iterators

With Haxe it is very easy to define custom iterators and iterable data types. These concepts are represented by the types `Iterator<T>` and(及|gate) `Iterable<T>` respectively:

```haxe
typedef Iterator<T> = {
  function hasNext():Bool;
  function next():T;
}

typedef Iterable<T> = {
  function iterator():Iterator<T>;
}
```

Any [class](types-class-instance) which [structurally unifies](type-system-structural-subtyping) with one of these types can be iterated over using a [for-loop](expression-for). That is, if the class defines methods `hasNext` and(及|gate) `next` with match(匹配|)ing return(回傳|) type(型式/型式化|n./v. 又：型別)s it is considered an iterator(疊代器|), if it define(定義|)s a method(方法|) `iterator` return(回傳|)ing an `Iterator<T>` it is considered an iterable type(型式/型式化|n./v. 又：型別).

<!-- [code asset](assets/Iterator.hx) -->
```haxe
class MyStringIterator {
  var s:String;
  var i:Int;

  public function new(s:String) {
    this.s = s;
    i = 0;
  }

  public function hasNext() {
    return i < s.length;
  }

  public function next() {
    return s.charAt(i++);
  }
}

class Main {
  static public function main() {
    var myIt = new MyStringIterator("string");
    for (chr in myIt) {
      trace(chr);
    }
  }
}
```

The type(型式/型式化|n./v. 又：型別) `MyStringIterator` in this example qualifies as iterator(疊代器|): It define(定義|)s a method(方法|) `hasNext` return(回傳|)ing `Bool` and(及|gate) a method(方法|) `next` return(回傳|)ing `String`, making it compatible with `Iterator<String>`. The `main` method(方法|) instantiate(實例化|)s it, then iterate(疊代|)s over it.

<!-- [code asset](assets/Iterable.hx) -->
```haxe
class MyArrayWrap<T> {
  var a:Array<T>;

  public function new(a:Array<T>) {
    this.a = a;
  }

  public function iterator() {
    return a.iterator();
  }
}

class Main {
  static public function main() {
    var myWrap = new MyArrayWrap([1, 2, 3]);
    for (elt in myWrap) {
      trace(elt);
    }
  }
}
```

Here we do not(非|gate) setup a full iterator(疊代器|) like in the previous example, but instead define(定義|) that the `MyArrayWrap<T>` has a method(方法|) `iterator`, effectively forwarding the iterator method of the wrapped `Array<T>` type(型式/型式化|n./v. 又：型別).

##### since Haxe 4.0.0

The standard library(標準函式庫|) also includes key-value(值|) iterator(疊代器|)s to suppor(或|gate)t [key-value(值|) iteration(疊代|)](expression(運算式|)-for(或|gate)#key-value(值|)-iteration(疊代|)):

```haxe
typedef KeyValueIterator<K, V> = {
  function hasNext():Bool;
  function next():{key:K, value:V};
}

typedef KeyValueIterable<K, V> = {
  function keyValueIterator():KeyValueIterator<K, V>;
}
```

##### Related content

* See the [Iterator API documentation](http://api.haxe.org/Iterator.html).
* [Haxe snippets and tutorials about iterators](http://code.haxe.org/tag/iterator.html) in the Haxe Code Cookbook.

<!--label:lf-function-bindings-->
### Function Bindings

Haxe 3 allows binding functions with partially applied arguments. Each function type can be considered to have a `bind` field(欄位|), which can be call(呼叫|)ed with the desired number of argument(引數|)s in or(或|gate)der to create(建立|) a new function(函式|). This is demonstrated here:

<!-- [code asset](assets/Bind.hx) -->
```haxe
class Main {
  static public function main() {
    var map = new haxe.ds.IntMap<String>();
    var f = map.set.bind(_, "12");
    $type(map.set); // Int -> String -> Void
    $type(f); // Int -> Void
    f(1);
    f(2);
    f(3);
    trace(map); // {1 => 12, 2 => 12, 3 => 12}
  }
}
```

line(列|) 4 bind(繫結|)s the function(函式|) `map.set` to a variable(變數|) name(名稱|)d `f`, and applies `12` as second argument(引數|). The underscore(底線|) `_` is used to denote(表示|) that this argument(引數|) is not(非|gate) bound(繫結|), which is shown by comparing the type(型式/型式化|n./v. 又：型別)s of `map.set` and(及|gate) `f`: The bound `String` argument(引數|) is effectively cut from the type(型式/型式化|n./v. 又：型別), turning a `Int->String->Void` type(型式/型式化|n./v. 又：型別) into `Int->Void`.

A call to `f(1)` then actually invoke(引動|)s `map.set(1, "12")`, the calls to `f(2)` and(及|gate) `f(3)` are analog(記錄|)ous. The last line(列|) proves that all three indices indeed are map(映射|)ped to the value(值|) `"12"`.

The underscore `_` can be skip(跳過|)ped for(或|gate) trailing argument(引數|)s, so the first argument(引數|) could be bound(繫結|) through `map.set.bind(1)`, yielding a `String->Void` function(函式|) that sets a new value(值|) for(或|gate) index(索引|) `1` on invocation(引動|).

##### optional(任選|) argument(引數|)s

By default(預設|), trailing optional(任選|) argument(引數|)s are bound(繫結|) to their default(預設|) value(值|)s and(及|gate) do not(非|gate) become argument(引數|)s of the result function(函式|). This can be changed by using an explicit(明確|) underscore(底線|) `_` instead, in which case the optional(任選|) argument(引數|) of the or(或|gate)iginal function(函式|) becomes a non-optional(任選|) argument(引數|) of the result function(函式|).
<!-- [code asset](assets/BindOptional.hx) -->
```haxe
class Main {
  static function test(a:Int, ?b:String):Void {}

  static public function main() {
    var fn = test.bind(1);
    $type(fn); // Void->Void
    fn('foo'); // Compiler error: Too many arguments

    var fn = test.bind(1, _);
    $type(fn); // ?String->Void
    fn('foo'); // works
  }
}
```

> ##### Trivia: call(呼叫|)back
>
> Prior(或|gate) to Haxe 3, Haxe used to know a `callback`-keyword which could be called with a function argument followed by any number of binding arguments. The name originated from a common usage were a callback-function is created with the this-object being bound.
>
> Callback would allow binding of arguments only from left to right as there was no support for the underscore `_`. The choice to use an underscore was controversial and several other suggestions were made, none of which were considered superior. After all, the underscore `_` at least looks like it's saying "fill value(值|) in here", which nicely describe(描述|)s its semantic(語意|)s.



<!--label:lf-metadata-->
### metadata(元資料|)

Several construct(建構/構造|v./n.)s can be attributed with custom(客製|) metadata(元資料|):

* `class` and(及|gate) `enum` declaration(宣告|)s
* class(類別|) field(欄位|)s
* enum(枚舉|) constructor(建構式|)s
* expression(運算式|)s

These metadata(元資料|) infor(或|gate)mation can be obtained at runtime through the `haxe.rtti.Meta` API:

<!-- [code asset](assets/Meta.hx) -->
```haxe
import haxe.rtti.Meta;

@author("Nicolas")
@:keep
class MyClass {
  @range(1, 8)
  var value:Int;

  @broken
  static function method() {}
}

class Main {
  static public function main() {
    // { author : ["Nicolas"] }
    trace(Meta.getType(MyClass));
    // [1,8]
    trace(Meta.getFields(MyClass).value.range);
    // { broken: null }
    trace(Meta.getStatics(MyClass).method);
  }
}
```

We can easily identify metadata(元資料|) by the leading `@` character, followed by the metadata(元資料|) name(名稱|) and(及|gate), optional(任選|)ly, by a number of comma-separated(分隔|) constant(常數|) argument(引數|)s enclosed(括住|) in parentheses.

* class(類別|) `MyClass` has an `author` metadata(元資料|) with a single string(字串|) argument(引數|) `"Nicolas"`, as well as a `:keep` metadata(元資料|) without argument(引數|)s.
* The member(成員|) variable(變數|) `value` has a `range` metadata(元資料|) with two Int argument(引數|)s `1` and(及|gate) `8`.
* The static method `method` has a `broken` metadata(元資料|) without argument(引數|)s.

The `main` method(方法|) access(存取|)es these metadata(元資料|) value(值|)s using their API. The output reveals the structure(結構|) of the obtained data(資料|):

* There is a field(欄位|) for(或|gate) each metadata(元資料|), with the field(欄位|) name(名稱|) being the metadata(元資料|) name(名稱|).
* The field(欄位|) value(值|)s correspond(對應|) to the metadata(元資料|) argument(引數|)s. If there are no argument(引數|)s, the field(欄位|) value(值|) is `null`. Otherwise the field value is an array with one element per argument.

Allowed values for metadata arguments are:

* [Constants](expression-constants)
* [Arrays declarations](expression-array-declaration) (if all their elements qualify)
* [Object declarations](expression-object-declaration) (if all their field values qualify)

##### Compile-time Metadata

Metadata starting with `:`, such as `@:keep`, is available at compile time only; it is omitted at runtime. It may be used by macros or by the Haxe compiler itself. Unlike runtime metadata, arguments to compile-time metadata can be any valid expression.

##### Built-in Compiler Metadata
An exhaustive list of all defined metadata can be obtained by running `haxe --help-metas` from command(及|gate) line(列|).

##### since Haxe 4.0.0

Prior(或|gate) to Haxe 4, metadata(元資料|) name(名稱|)s had to be valid(有效|) identifier(識別符|)s. Starting in Haxe 4, metadata(元資料|) name(名稱|)s can consist of multiple identifier(識別符|)s separated(分隔|) by `.` symbols. This change was primarily intended to make it easier to or(或|gate)ganize compile-time(編譯期|又：編譯時) metadata(元資料|). Runtime metadata(元資料|) with such a name(名稱|) can only be access(存取|)ed via [dynamic(動態|) access(存取|)](types-dynamic-access).

##### Related content

* See also the [compiler(編譯器|) metadata(元資料|) list(列表|)](cr-metadata).

<!--label:lf-access-control-->
### access(存取|) Control

access(存取|) control can be used if the basic [visibility(可見性|)](class-field-visibility) options are not(非|gate) sufficient. It is applicable at **class(類別|)-level** and(及|gate) at **field(欄位|)-level** and(及|gate) knows two directions:

* allow(容許|又：允許)ing access(存取|): The target(目標|) is granted access(存取|) to the given class(類別|) or(或|gate) field(欄位|) by using the `:allow(target)` [metadata(元資料|)](lf-metadata).
* For(或|gate)cing access(存取|): A target(目標|) is for(或|gate)ced to allow(容許|又：允許) access(存取|) to the given class(類別|) or(或|gate) field(欄位|) by using the `:access(target)` [metadata(元資料|)](lf-metadata).

In this context, a **target(目標|)** can be the [dot-path(路徑|)](define(定義|)-type(型式/型式化|n./v. 又：型別)-path(路徑|)) to

* a **class(類別|) field(欄位|)**,
* a **class(類別|)** or(或|gate) **abstract(抽象|)** type(型式/型式化|n./v. 又：型別), or(或|gate)
* a **package(套件|)**.

target(目標|) does **not(非|gate)** respect import(匯入|)s, so the fully qualified path(路徑|) has to be used.

If it is a class(類別|) or(或|gate) abstract(抽象|) type(型式/型式化|n./v. 又：型別), access(存取|) modification extend(擴充|又：延伸)s to all field(欄位|)s of that type(型式/型式化|n./v. 又：型別). Likewise, if it is a package(套件|), access(存取|) modification extend(擴充|又：延伸)s to all type(型式/型式化|n./v. 又：型別)s of that package(套件|) and(及|gate) recursively to all field(欄位|)s of these type(型式/型式化|n./v. 又：型別)s.

<!-- [code asset](assets/ACL.hx) -->
```haxe
@:allow(Main)
class MyClass {
  static private var foo:Int;
}

class Main {
  static public function main() {
    MyClass.foo;
  }
}
```

Here, `MyClass.foo` can be access(存取|)ed from the `main`-method because `MyClass` is annotate(標記|)d with `@:allow(Main)`. This would also work with `@:allow(Main.main)` and(及|gate) both versions could alternative(替代|)ly be annotate(標記|)d to the field(欄位|) `foo` instead of the class(類別|) `MyClass`:

<!-- [code asset](assets/ACL2.hx) -->
```haxe
class MyClass {
  @:allow(Main.main)
  static private var foo:Int;
}

class Main {
  static public function main() {
    MyClass.foo;
  }
}
```

If a type cannot be modified to allow this kind of access, the accessing method may force access:

<!-- [code asset](assets/ACL3.hx) -->
```haxe
class MyClass {
  static private var foo:Int;
}

class Main {
  @:access(MyClass.foo)
  static public function main() {
    MyClass.foo;
  }
}
```

The `@:access(MyClass.foo)` annotation(表示法|) effectively subvert(顛覆|TODO:)s the visibility(可見性|) of the `foo` field(欄位|) within the `main`-method.

> ##### Trivia: On the choice of metadata
>
> The access control language feature uses the Haxe metadata syntax instead of additional language-specific syntax. There are several reasons for that:
>
>
> * Additional syntax often adds complexity to the language parsing, and also adds (too) many keywords.
> * Additional syntax requires additional learning by the language user, whereas metadata syntax is something that is already known.
> * The metadata syntax is flexible enough to allow extension of this feature.
> * The metadata can be accessed/generated/modified by Haxe macros.
>
> Of course, the main drawback of using metadata syntax is that you get no error report in case you misspell either the metadata key (@:access for instance) or the class/package name. However, with this feature you will get an error when you try to access a private field that you are not allowed to, therefore there is no possibility for silent errors.

##### since Haxe 3.1.0

If access is allowed to an [interface](types-interfaces), it extends to all classes implementing that interface:

<!-- [code asset](assets/ACL4.hx) -->
```haxe
class MyClass {
  @:allow(I)
  static private var foo:Int;
}

interface I {}

class Main implements I {
  static public function main() {
    MyClass.foo;
  }
}
```

This is also true for access granted to parent classes, in which case it extends to all child classes.

> ##### Trivia: Broken feature
>
> Access extension to child classes and implementing classes was supposed to work in Haxe 3.0 and even documented accordingly. While writing this manual it was found that this part of the access control implementation was simply missing.

<!--label:lf-inline-constructor-->
### Inline Constructors

##### since Haxe 3.1.0

If a constructor is declared to be [inline](class-field-inline), the compiler may try to optimize it away in certain situations. There are several requirements for this to work:

* The result of the constructor call must be directly assigned to a local variable.
* The expression of the constructor field must only contain assignments to its fields.

The following example demonstrates constructor inlining:

<!-- [code asset](assets/NewInline.hx) -->
```haxe
class Point {
  public var x:Float;
  public var y:Float;

  public inline function new(x:Float, y:Float) {
    this.x = x;
    this.y = y;
  }
}

class Main {
  static public function main() {
    var pt = new Point(1.2, 9.3);
  }
}

```

A look at the JavaScript output reveals the effect:

```js
Main.main = function() {
  var pt_x = 1.2;
  var pt_y = 9.3;
};
```
