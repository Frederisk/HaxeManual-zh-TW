<!--label:lf-->
# 語言特徵

**[抽象型式](types-abstract)：**

抽象型式是編譯期構造，其在執行期以不同的方式表述。這容許給已存在的型式以全新的含意。

**[外部類別](lf-externs)：**

外部可用於以型式安全的方式描述目標特定的互動。

**[匿名結構](types-anonymous-structure)**

資料可以在結構中輕鬆歸併，從而最大限度地減少小型資料類別的必要性。

```haxe
var point = {x: 0, y: 10};
point.x += 10;
```

**[陣列理解](lf-array-comprehension)：**

以迴圈與邏輯快速建立並填入陣列。

```haxe
var evenNumbers = [for (i in 0...100) if (i & 1 == 0) i];
```

**[映射理解](lf-map-comprehension)：**

以迴圈與邏輯快速建立並填入映射。

```haxe
var primality = [for (i in 0...100) i => isPrime(i)];
```

**[類別、介面與繼承](types-class-instance)：**

Haxe 容許在類別中結構化程式碼，這使其成為物件導向的語言。Haxe 支援在 Java 等語言中常見特徵，包括繼承與介面。

**[條件編譯](lf-condition-compilation)：**

條件編譯容許根據編譯參數編譯特定程式碼。這有助於抽象出目標特定的差異，不過也可以用於其他目的，比如更詳細的測試。

```haxe
#if js
  js.Browser.alert("Hello");
#elseif sys
  Sys.println("Hello");
#end
```

**[（通用）代數資料型別](types-enum-instance)：**

結構可透過代數資料型別（ADT）表示，這在 Haxe 語言中也就是枚舉。另外，Haxe 支援稱為 GADT 的通用變體。

```haxe
enum Result {
  Success(data:Array<Int>);
  UserError(msg:String);
  SystemError(msg:String, position:PosInfos);
}
```

**[內聯呼叫](class-field-inline)：**

可以將函式指定為內聯，這容許在呼叫處插入其程式碼。這可產生顯著的效能優勢，並且無須以複製程式碼來手動內聯。

**[疊代器](lf-iterators)：**

在 Haxe 很容易利用疊代器去疊代如陣列的元素的一系列值。客製類別可以快速實作疊代器功能以容許疊代。

```haxe
for (i in [1, 2, 3]) {
  trace(i);
}
```

**[局部函式與閉包](expression-arrow-function)：**

Haxe 並不只限至於成為類別欄位，在運算式中也可以宣告以使用強大的閉包。

```haxe
var buffer = "";
function append(s:String) {
  buffer += s;
}
append("foo");
append("bar");
trace(buffer); // foobar
```

**[元資料](lf-metadata)：**

將元資料添加至欄位、類別或運算式中可以將資訊傳遞至編譯器、巨集或者執行期類別。

```haxe
class MyClass {
  @range(1, 8) var value:Int;
}
trace(haxe.rtti.Meta.getFields(MyClass).value.range); // [1,8]
```

**[靜態延伸]（lf-static-extension）：**

既有的類別和其他型式可以透過靜態延伸來增添額外功能。

```haxe
// using StringTools; FIXME:
"  Me & You    ".trim().htmlEscape();
```

**[字串插值](lf-string-interpolation)：**

以單引號宣告的字串可以存取當前上下文中的變數。

```haxe
trace('My name is $name and I work in ${job.industry}');
```

**[部分函式應用](lf-function-bindings)：**

任何函式都可以提供其中一些引數的值以部分應用，而將其餘的留以之後填寫。

```haxe
var map = new haxe.ds.IntMap();
var setToTwelve = map.set.bind(_, 12);
setToTwelve(1);
setToTwelve(2);
```

**[模式匹配](lf-pattern-matching)：**

複雜的結構可以與模式匹配，從枚舉或結構中提取資訊，並為特定的值組合定義特定的運算。

```haxe
var a = {foo: 12};
switch a {
  case {foo: i}: trace(i);
  default:
}
```

**[屬性](class-field-property)：**

變數類別欄位可以設計為具有自訂讀寫存取的屬性，從而進行更細緻的存取控制。

```haxe
public var color(get,set);
function get_color() {
  return element.style.backgroundColor;
}
function set_color(c:String) {
  trace('Setting background of element to $c');
  return element.style.backgroundColor = c;
}
```

**[存取控制](lf-access-control)：**

存取控制語言特徵以 Haxe 元資料語法強制或容許控制類別或欄位。

**[型式參數、約束與變異數](type-system-type-parameters)：**

可以以型式參數對型式參數化，從而容許型式化容器與其他複雜資料結構。型式參數也可限制為某些型式並遵守變異數規則。

```haxe
class Main<A> {
  static function main() {
    new Main<String>("foo");
    new Main(12); // 使用型式推斷
  }

  function new(a:A) {}
}
```

<!--label:lf-condition-compilation-->
## 條件編譯

Haxe 容許使用 `#if`、`#elseif` 和 `#else` 並檢查編譯器旗標來條件編譯。

> #### 定義： 編譯器旗標
>
> 編譯器旗標是可配置的值，其可以影響編譯處理。可以在引動命令列時用 `-D key=value` 或僅用 `-D key` 來設定這些值，其中後者的值莫認為 `"1"`。編譯器在內部還設定有幾個旗標，這可以在不同的編譯步驟之間傳遞資訊。

這個例子演示了條件編譯的用法：

<!-- [code asset](assets/ConditionalCompilation.hx) -->
```haxe
class Main {
  public static function main() {
    #if !debug
    trace("ok");
    #elseif (debug_level > 3)
    trace(3);
    #else
    trace("debug level too low");
    #end
  }
}
```

在沒有任何任何旗標的情況下編譯將只會留下在 `main` 方法本體中的 `trace("ok");` 列，而在解析檔案時會將其他分支丟棄。這些分支仍需要包含有效的 Haxe 語法，但程式碼將不會有型式檢查。

在 `#if` 和 `#elseif` 之後的條件容許有以下運算式：

- 任何識別符都將由同名稱的編譯器旗標所替代。須注意命令列中的 `-D some-flag` 會使旗標 `some-flag` 與 `some_flag` 定義。
- `String`、`Int` 和 `Float` 常數的值可以直接使用。
- 布林運算子 `&&`（及）、`||`（或）和 `!`（非）將按預期工作，但整個運算式必須完全包含在括號中。
- 運算子 `==`、`!=`、`>`、`>=`、`<`、`<=` 可用於比較值。
- 括號 `()` 和往常一樣可用於為運算式分組。

Haxe 剖析器不會將 `some-flag` 剖析為單個語彙基元，而是會將其作為減法二元運算子 `some - flag` 讀出。在這種情況下，必須使用底線版本 `some_flag`。

#### 使用編譯器旗標

編譯器旗標在編譯期可用，下列方法僅用於巨集上下文中：

- 要察看是編譯期旗標是否設定，可用 `haxe.macro.Context.defined("any_flag")`。
- 要獲取編譯期旗標的值，可用 `haxe.macro.Context.definedValue("any_flag")`。
- 要獲取所有編譯器旗標及其值的映射，可用 `haxe.macro.Context.getDefines()`。

#### Haxelibs

在默認情況下，每個使用的 haxelib 的版本都會自動添加為旗標，例如添加 `-L actuate` 時，編譯器會添加 `-D actuate=1.8.7`。要測試當前的上下文中是否存在函式庫，可使用 `#if actuate`。要檢查特定的 haxelib 版本，可使用運算子，比如 `#if (actuate <= "1.8.7")`。

#### 內建編譯器旗標

可以透過 `--help-defines` 引數引動 Haxe 編譯器來獲取所有內建定義的詳細列表。Haxe 編譯器容許在每次編譯時有多個 `-D` 旗標。

#### 相關內容

- 參見 [編譯器其旗標列表](compiler-usage-flags).

<!--label:lf-target-defines-->
#### 目標定義

根據當前目標，將會定義下列旗標中的至少一個。注意，這些與[提供給編譯器以指定輸出的引數](compiler-usage)相同。

- `cpp` 會在產生 C++ 程式碼或 cppia 腳本時定義。
- `cppia` 會在產生 cppia 腳本時定義。
- `cs` 會在產生 C# 程式碼時定義。
- `eval` 會在以 `--interp` 執行程式碼或者在巨集上下文中執行時定義。
- `hl` 會在產生 HashLink 程式碼時定義。
- `java` 會在產生 Java 或 JVM 程式碼時定義。
- `js` 會在產生 JavaScript 程式碼時定義。
- `lua` 會在產生 Lua 程式碼時定義。
- `neko` 會在產生 Neko二進位檔時定義。
- `php` 會在產生 PHP 程式碼時定義。
- `python` 會在產生 Python 程式碼時定義。
- `swf` 會在產生 SWF 檔案時定義。

此外，部分程式碼可用於巨集上下文或在顯示完成期間。這些旗標可用於檢查是否屬於這些情況：

- `display` 會在提供程式碼完成時定義。
- `macro` 會在巨集上下文中定義。

#### 支援的特徵

- `sys` 會定義目標是否支援 [sys API](std-sys)。

#### 自 Haxe 4.0.0

為提供有關當前目標支援功能的更細緻的資訊且不需要手動去檢查哪個目標支援甚麼，Haxe 4 為此提供了 `target.*` 的定義：

- `target.static`（或 `static`）會在目標為[靜態](types-nullability)時定義。
- `target.sys`（或之前提到的 `sys`）會定義目標是否支援 sys API。
- `target.utf16`（或 `utf16`）會在目標使用 UTF-16 作為[內部字串表述方式](std-String)時定義。
- `target.threaded` 會定義目標是否是否支援[執行緒 API](std-threading)。
- `target.name` 會定義為目標的名稱，例如 `js`。

<!--label:lf-target-specific-files-->
### 目標特定檔案

#### 自 Haxe 4.0.0

除了以編譯期檢查環繞個程式碼的各個部份外，還可以為編譯器提供完全獨立的特定目標的模組替代。該特徵的運作如下：

- 當編譯器找到檔案 `<Module>.hx` 時會檢查其包含目錄來找出名為 `<Module>.<target>.hx` 的檔案，其中 `<target>` 為當前目標的名稱。
- 模組的主檔案（沒有目標特定副檔名）必須存在。
- 若找到了目標特定檔案則主檔案完全不會載入，須注意這也意味著不會在主檔案中檢查錯誤。

比如，我們可以有以下目錄結構：

```haxe
/somepackage/Example.hx
/somepackage/Example.js.hx
/Main.hx
```

在 `Main.hx` 中我們可以使用 `somepackage.Example` 模組。該模駔在 `somepackage/Example.hx` 中定義。不過若我們編譯為 JavaScript，則該模組會在檔案 `somepackage/Example.js.hx` 中定義。

<!--label:lf-externs-->
## 外部

外部可用於以型式安全方式描述特定於目標的互動，其定義與與普通的類別相同，除了

- `class` 關鍵字前有 `extern` 關鍵字、
- [方法](class-field-method)沒有運算式、
- 所有的引數和回傳型式都是明確的、
- 其預設可見性為 `public`（`private` 需要以明確指定）。

[Haxe 標準函式庫](std)中的一個常見例子是 `Math` 類別，如摘錄所示：

```haxe
extern class Math {
  static var PI(default,null):Float;
  static function floor(v:Float):Int;
}
```

我們可以看到外部可以於方法和變數上定義（實際上，`PI` 宣告為唯獨[屬性](class-field-property)）。編譯器一旦可以使用此資訊，就會相應容許欄位存取並得知其型式。

<!-- [code asset](assets/Extern.hx) -->
```haxe
class Main {
  static public function main() {
    var pi = Math.floor(Math.PI);
    $type(pi); // Int
  }
}
```

這可以工作，因為 `floor` 的回傳型式宣告為 `Int`。

Haxe 標準函式庫有許多對 Flash 與 JavaScript 目標的外部。它們容許以型式安全方式存取原生 API，並且有助於設計更高階的 API。[haxelib](haxelib) 上還有許多流行的原生函式庫。

Flash、Java 和 C# 目標容許從[命令列](compiler-usage)直接包含原生函式庫。目標特定的細節於[目標細節](target-details)的各部分有介紹。

一些目標，比如 Python 或 JavaScript，可能會需要產生額外的「匯入」程式碼以自原生模組中載入 `extern` 類別。Haxe 提供了宣告這些依賴的方法，這些也在[目標細節](target-details)的各部分有介紹。

#### 剩餘引數與型式選擇

#### 自 Haxe 3.2.0

haxe.extern 套件提供了兩種型式以幫助將原生語意映射至 Haxe：

- `Rest<T>`：此型式可用作最後的函式引數以容許傳遞任意數量的附加呼叫引數。其型式參數可用於限定這些引數為特定型式。
- `EitherType<T1,T2>`：此型式容許使用其任一參數型式並由此表示型式選擇。其可以巢套使用以容許使用兩種以上的不同型式。

我們在此程式碼樣例中演示了其用法：

<!-- [code asset](assets/RestAndEitherType.hx) -->
```haxe
import haxe.extern.Rest;
import haxe.extern.EitherType;

extern class MyExtern {
  static function f1(s:String, r:Rest<Int>):Void;
  static function f2(e:EitherType<Int, String>):Void;
}

class Main {
  static function main() {
    MyExtern.f1("foo", 1, 2, 3); // 將 1, 2, 3 用作剩餘引數
    MyExtern.f1("foo"); // 無剩餘引數
    // MyExtern.f1("foo", "bar"); // String 應當為 Int

    MyExtern.f2("foo");
    MyExtern.f2(12);
    // MyExtern.f2(true); // Bool 應當為 EitherType<Int, String>
  }
}
```

#### 可見性

外部支援 `private` 可見性修飾符。不過，由於外部類別的預設可見性是 `public`，因此需要明確指定為 `private`。

在 API 打算容許覆寫函式時指定 `private` 成員十分有用。此外，Haxe 無法阻止次類別重複使用欄位名稱，除非這些欄位包含在外部定義中。這對類如 JavaScript 的不支援將超類別欄位名稱作為新欄位重複使用的目標來說很重要。

```haxe
extern class ExampleSuperClass {
  // 需要次類別化來使用
  private function new();

  // 只容許次類別存取該可覆寫的函式
  private function overridableFunction():String;

  // 該函式是隱含公開的
  function doSomething():String;
}
```

<!--label:lf-externs-native-->
### 原生元資料

在建立外部時某些欄位可能會與 Haxe 關鍵字衝突，即便對於目標來說它們是有效識別符。這些問題可以使用元資料 `:native` 標記來解決，可以將預期的識別符作為參數提供。

<!-- [code asset](assets/ExternNative.hx) -->
```haxe
extern class A {
  public function new();
  @:native("final") var final_:Int;
}

class Main {
  public static function main():Void {
    var a = new A();
    a.final_ = 3;
  }
}
```

產生的 JavaScript 輸出顯示我們實際將指派給了 `final` 欄位：

```js
(function ($global) { "use strict";
var Test = function() { };
Test.main = function() {
  new A().final = 3;
};
Test.main();
})({});
```

此元資料可套用至類別與介面欄位，但無法適用於結構型式的欄位。

<!--label:types-dynamic-implemented-->
### 實作動態

外部類別可[實作](types-interfaces)開啟任意欄位存取的 `Dynamic` 與 `Dynamic<T>`。對前者，欄位可以有任意型式，而對於後者，則其限制為須與參數型式相容：

<!-- [code asset](assets/ImplementsDynamic.hx) -->
```haxe
extern class ImplementsDynamic implements Dynamic<String> {
  public var present:Int;
  public function new();
}

class Main {
  static public function main() {
    var c = new ImplementsDynamic();
    // valid, present is an existing field
    c.present = 1;
    // valid, assigned value is a String
    c.stringField = "foo";
    // error, Int should be String
    // c.intField = 1;
  }
}
```

實作 `Dynamic` 不會滿足其他實作介面的需求。預期的欄位仍必需明確實作。

> #### 雜項：於非外部上實作 `Dynamic`
>
> 自 Haxe 4 起，實作 `Dynamic` 只容許於外部類別之上。在過往版本中，任意類別都可實作 `Dynamic` 並容許讀出或寫入任意欄位。此外，特殊的 `resolve` 方法可用於解析對不存在欄位的讀出存取。而現在可用的特徵是抽象中的[運算子多載](types-abstract-operator-overloading)。

<!--label:lf-static-extension-->
## 靜態延伸

> #### 定義：靜態延伸
>
> 靜態延伸容許在不修改源頭的情況下偽擴充現有的型式。在 Haxe 中，這是透過以擴充型式的第一個引數來宣告靜態方法，然後以 `using` 將定義類別引入上下文來達成的。

靜態延伸可以是很強大的工具，它可以讓你在不實際變更型式的同時也能增強型式。以下的例子演示了用法：

<!-- [code asset](assets/StaticExtension.hx) -->
```haxe
// using Main.IntExtender; FIXME:

class IntExtender {
  static public function triple(i:Int) {
    return i * 3;
  }
}

class Main {
  static public function main() {
    trace(12.triple());
  }
}
```

顯然，`Int` 並沒有原生提供 `triple` 方法，不過該程式還是可以按預期編譯並輸出 `36`。這是由於對 `12.triple()` 的呼叫會轉換為 `IntExtender.triple(12)`。為完成此，有三個需求：

1. 常值 `12` 與 `triple` 的第一個引數都是 `Int` 型式。
2. 類別 `IntExtender` 會透過 `using Main.IntExtender` 進入上下文。
3. `Int` 本身並沒有 `triple` 欄位（如果有的話，該欄位將有比靜態延伸更高的優先權）。

靜態延伸通常會視作是語法糖而且也確實如此，不過值得注意的是這可以對程式碼的可讀性帶來巨大影響：可以用 `x.f4().f3().f2().f1()` 形式的鏈式呼叫來取代 `f1(f2(f3(f4(x))))` 形式的巢狀呼叫。

以之前在[解析順序](type-system-resolution-order)中所描述的那樣，多個 `using` 運算式會自底向頂檢查每個模組中的型式以及每個型式中的欄位。使用模組（與特定型式相反，參見[模組和路徑](type-system-modules-and-paths)）作為靜態延伸將其所有的型式帶入上下文。

靜態延伸關鍵字 `using` 也意味著 [`import`](type-system-import)同一模組的效果。

#### 相關內容

- Haxe Code Cookbook 中[有關靜態延伸的 Haxe 程式碼片段與教學](http://code.haxe.org/tag/static-extension.html)。

<!--label:lf-static-extension-in-std-->
### 在 Haxe 標準函式庫中

在 Haxe 標準函式庫中的個別類別很適合靜態延伸使用。下一個例子展示了 `StringTools` 的用法：

Several classes in the Haxe Standard Library are suitable for static extension usage. The next example shows the usage of `StringTools`:

<!-- [code asset](assets/StaticExtension2.hx) -->
```haxe
// using StringTools; FIXME:

class Main {
  static public function main() {
    "adc".replace("d", "b");
  }
}
```

雖然 `String` 自己本身並沒有 `replace` 功能，但 `using StringTools` 可以提供。如同往常，JavaScript 輸出很好地展示了轉換效果：

```js
Main.main = function() {
  StringTools.replace("adc","d","b");
}
```

The following classes from the Haxe Standard Library are designed to be used as static extensions:

* [StringTools](https://api.haxe.org/StringTools.html): Provides extended functionality on strings, such as replacing or trimming.
* [Lambda](https://api.haxe.org/Lambda.html): Provides functional methods on iterables.
* [haxe.EnumTools](https://api.haxe.org/haxe/EnumTools.html): Provides type information functionality on enums and their instances.
* `haxe.macro.Tools`: Provides different extensions for working with macros (see [Tools](macro-tools)).

> ##### Trivia: "using" using
>
> Since the `using` keyword(關鍵字|) was added to the language, it has been common to talk about certain problems with "using using" or(或|gate) the effect of "using using". This makes for(或|gate) awkward English in many(任意|) cases, so the author(或|gate) of this manual(手冊/手動|n./adj.) decided to call(呼叫|) the feature(特徵|) by what it actually is: static(靜態|) extension(延伸|).

<!--label:lf-static-extension-metadata-->
#### static(靜態|) extension(延伸|) metadata(元資料|)

##### since Haxe 4.0.0

##### Exclusion from static(靜態|) extension(延伸|)

By default(預設|), using a class(類別|) as a static(靜態|) extension(延伸|) brings all of its static(靜態|) method(方法|)s into the context, allow(容許|又：允許)ing them to be used as extension(延伸|)s of the appropriate type(型式/型式化|n./v. 又：型別)s. In certain situations, the class(類別|) can provide other static(靜態|) method(方法|)s which are not(非|gate) intended for(或|gate) static(靜態|) extension(延伸|). To make sure they do not(非|gate) interfere with the proper method(方法|)s of the type(型式/型式化|n./v. 又：型別), these method(方法|)s can be marked with `@:noUsing`:

<!-- [code asset](assets/StaticExtension3.hx) -->
```haxe
// using Main.IntExtender; FIXME:

class IntExtender {
  @:noUsing static public function double(i:Int) {
    return i * 2;
  }

  static public function triple(i:Int) {
    return i * 3;
  }
}

class Main {
  static public function main() {
    // works:
    trace(12.triple());
    // does not work because the method is marked with @:noUsing:
    // trace(12.double());
    // works as a normal static method:
    trace(IntExtender.double(12));
  }
}
```

##### Default Static Extension

It is also possible to always enable particular static extensions for a given type, by annotating the type with the `@:using(args...)` metadata(元資料|). The argument(引數|)s are the full dot path(路徑|)s of static(靜態|) extension(延伸|) class(類別|)es that will be applied on the type(型式/型式化|n./v. 又：型別):

<!-- [code asset](assets/StaticExtension4.hx) -->
```haxe
@:using(Main.TreeTools)
enum Tree {
  Node(l:Tree, r:Tree);
  Leaf(value:Int);
}

class TreeTools {
  public static function sum(tree:Tree):Int {
    return (switch (tree) {
      case Node(l, r): sum(l) + sum(r);
      case Leaf(value): value;
    });
  }
}

class Main {
  static public function main() {
    var a = Node(Node(Leaf(1), Leaf(2)), Leaf(3));
    // works, even though there was no 'using Main.TreeTools' in this module
    trace(a.sum());
  }
}
```

<!--label:lf-pattern-matching-->
### pattern matching(模式匹配|)

<!--subtoc-->

<!--label:lf-pattern-matching-introduction-->
#### Introduction

pattern matching(模式匹配|) is the process(處理|) of branching depending on a value(值|) match(匹配|)ing given, possibly deep patterns. In Haxe, pattern matching(模式匹配|) is primarily done within [`switch` expression(運算式|)s](expression(運算式|)-switch) where the individual `case` expression(運算式|)s represent(表述|) the patterns. Here we will explor(或|gate)e the syntax(語法|) for(或|gate) different patterns using this data structure(資料結構|) as running example:

<!-- [code asset](assets/Tree.hx) -->
```haxe
enum Tree<T> {
  Leaf(v:T);
  Node(l:Tree<T>, r:Tree<T>);
}
```

Some pattern match(匹配|)er basics include:

* Patterns will always be match(匹配|)ed from top to bottom(自頂向底|).
* The topmost pattern that match(匹配|)es the input value(值|) has its expression(運算式|) execute(執行|)d.
* A `_` pattern match(匹配|)es any(任意|)thing, so `case _`: is equal to `default:`

##### Related content

* More about the [switch expression](expression-switch).
* [Haxe snippets and tutorials about pattern matching](http://code.haxe.org/tag/pattern-matching.html) in the Haxe Code Cookbook.

<!--label:lf-pattern-matching-enums-->
#### Enum matching

Enums can be matched by their constructors in a natural way:

<!-- [code asset](assets/PatternMatching1.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
var match = switch (myTree) {
    // matches any Leaf
    case Leaf(_): "0";
    // matches any Node that has r = Leaf
    case Node(_, Leaf(_)): "1";
    // matches any Node that has
    // r = another Node, which has
    // l = Leaf("bar")
    case Node(_, Node(Leaf("bar"), _)): "2";
    // matches anything
    case _: "3";
  }
trace(match); // 2
```

The pattern matcher will check each case from top to bottom and pick the first one that matches the input value. The following manual interpretation of each case rule helps understanding the process:

* `case Leaf(_)`: matching fails because `myTree` is a `Node`
* `case Node(_, Leaf(_))`: matching fails because the right sub-tree of `myTree` is not(非|gate) a `Leaf`, but another `Node`
* `case Node(_, Node(Leaf("bar"), _))`: matching succeeds
* `case _`: this is not checked here because the previous line matched

<!--label:lf-pattern-matching-variable-capture-->
#### Variable capture

It is possible to catch any value of a sub-pattern by matching it against an identifier:

<!-- [code asset](assets/PatternMatching2.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
var name = switch (myTree) {
    case Leaf(s): s;
    case Node(Leaf(s), _): s;
    case _: "none";
  }
trace(name); // foo
```

This would return one of the following:

* If `myTree` is a `Leaf`, its name is returned.
* If `myTree` is a `Node` whose left sub-tree is a `Leaf`, its name is returned (this will apply here, returning `"foo"`).
* Otherwise `"none"` is return(回傳|)ed.

It is also possible to use `=` to capture value(值|)s which are further match(匹配|)ed:

<!-- [code asset](assets/PatternMatching3.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
var node = switch (myTree) {
    case Node(leafNode = Leaf("foo"), _): leafNode;
    case x: x;
  }
trace(node); // Leaf(foo)
```

Here, `leafNode` is bound(繫結|) to `Leaf("foo")` if the input match(匹配|)es that. In all other cases, `myTree` itself is return(回傳|)ed: `case x` wor(或|gate)ks similar to `case _` in that it match(匹配|)es any(任意|)thing, but with an identifier(識別符|) name(名稱|) like `x` it also bind(繫結|)s the match(匹配|)ed value(值|) to that variable(變數|).

##### since Haxe 4.0.0

If the compiler(編譯器|) detects that the name(名稱|) of a "catch(捕捉|)-all" variable(變數|) is very similar to an enum(枚舉|) constructor(建構式|), it will warn about a potential typo. This can be avoided by prefix(前綴|又：前置)ing the variable(變數|) identifier(識別符|) with `var`:

<!-- [code asset](assets/PatternMatching4.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
switch (myTree) {
  case Leaf(_):
  // ...
  case var node:
    // without var above the compiler would warn about a potential typo
    // node contains the entire matched tree
}
```

Any capture variable can be prefixed with `var`, even within sub-patterns.

<!--label:lf-pattern-matching-structure-->
#### Structure matching

It is also possible to match against the fields of anonymous structures and instances:

<!-- [code asset](assets/PatternMatching5.hx) -->
```haxe
var myStructure = {
  name: "haxe",
  rating: "awesome"
};
var value = switch (myStructure) {
    case {name: "haxe", rating: "poor"}:
      throw false;
    case {rating: "awesome", name: n}:
      n;
    case _:
      "no awesome language found";
  }
trace(value); // haxe
```

In the second case we bind the matched `name` field(欄位|) to identifier(識別符|) `n` if `rating` match(匹配|)es `"awesome"`. Of course this structure could also be put into the `Tree` from the previous example to combine structure(結構|) and(及|gate) enum(枚舉|) match(匹配|)ing.

<!--label:lf-pattern-matching-array-->
#### array(陣列|) match(匹配|)ing

array(陣列|)s can be match(匹配|)ed on fixed length:

<!-- [code asset](assets/PatternMatching6.hx) -->
```haxe
var myArray = [1, 6];

var match = switch (myArray) {
    case [2, _]: "0";
    case [_, 6]: "1";
    case []: "2";
    case [_, _, _]: "3";
    case _: "4";
  }
trace(match); // 1
```

This will trace `1` because `myArray[1]` match(匹配|)es `6`, and `myArray[0]` is allow(容許|又：允許)ed to be any(任意|)thing.

<!--label:lf-pattern-matching-or-->
#### or(或|gate) patterns

The `|` operator(運算子|) can be used any(任意|)where within patterns to describe(描述|) multiple accepted patterns:

<!-- [code asset](assets/PatternMatching7.hx) -->
```haxe
var match = switch (7) {
    case 4 | 1: "0";
    case 6 | 7: "1";
    case _: "2";
  }
trace(match); // 1
```

If there is a captured variable(變數|) in an or(或|gate)-pattern, it must appear in both its sub-patterns.

<!--label:lf-pattern-matching-guards-->
#### Guards

It is also possible to further restrict patterns with the `case ... if (condition):` syntax(語法|):

<!-- [code asset](assets/PatternMatching8.hx) -->
```haxe
var myArray = [7, 6];
var s = switch (myArray) {
    case [a, b] if (b > a):
      b + ">" + a;
    case [a, b]:
      b + "<=" + a;
    case _: "found something else";
  }
trace(s); // 6<=7
```

The first case has an additional(附加|) guard condition(條件|) `if (b > a)`. It will only be selected if that condition holds, otherwise matching continues with the next case.

<!--label:lf-pattern-matching-tuples-->
#### Match on multiple values

Array syntax can be used to match on multiple values:

<!-- [code asset](assets/PatternMatching9.hx) -->
```haxe
var s = switch [1, false, "foo"] {
    case [1, false, "bar"]: "0";
    case [_, true, _]: "1";
    case [_, false, _]: "2";
  }
trace(s); // 2
```

This is quite similar to usual array matching, but there are differences:

* The number of elements is fixed, so patterns of different array length will not be accepted.
* It is not possible to capture the switch value in a variable, i.e. `case x` is not(非|gate) allow(容許|又：允許)ed (`case _` still is).

<!--label:lf-pattern-matching-extractors-->
#### extract(擷取|又：抽取)or(或|gate)s

##### since Haxe 3.1.0

extract(擷取|又：抽取)or(或|gate)s allow(容許|又：允許) apply(套用|)ing transfor(或|gate)mations to value(值|)s being match(匹配|)ed. This is often useful when a small operation(運算|) is required on a match(匹配|)ed value(值|) before(前於|) match(匹配|)ing can continue:

<!-- [code asset](assets/Extractor2.hx) -->
```haxe
enum Test {
  TString(s:String);
  TInt(i:Int);
}

class Main {
  static public function main() {
    var e = TString("fOo");
    switch (e) {
      case TString(temp):
        switch (temp.toLowerCase()) {
          case "foo": true;
          case _: false;
        }
      case _:
        false;
    }
  }
}
```

Here we have to capture the argument(引數|) value(值|) of the `TString` enum(枚舉|) constructor(建構式|) in a variable(變數|) `temp` and(及|gate) use a nested(巢套|) switch on `temp.toLowerCase()`. Obviously, we want matching to succeed if `TString` hold(儲存|TODO:又：存儲)s a value(值|) of `"foo"` regardless of its casing. This can be simplified with extract(擷取|又：抽取)or(或|gate)s:

<!-- [code asset](assets/Extractor.hx) -->
```haxe
enum Test {
  TString(s:String);
  TInt(i:Int);
}

class Main {
  static public function main() {
    var e = TString("fOo");
    var success = switch(e) {
      case TString(_.toLowerCase() => "foo"):
        true;
      case _:
        false;
    }
  }
}
```

extract(擷取|又：抽取)or(或|gate)s are identified by the `extractorExpression => match` expression(運算式|). The compiler(編譯器|) generate(產生|)s code which is similar to the previous example, but the or(或|gate)iginal syntax(語法|) was greatly simplified. extract(擷取|又：抽取)or(或|gate)s consist of two parts, which are separated(分隔|) by the `=>` operator(運算子|):

1. The left side can be any(任意|) expression(運算式|), where all occurrences of underscore(底線|) `_` are replaced with the currently match(匹配|)ed value(值|).
2. The right side is a pattern which is match(匹配|)ed against the result of the evaluation of the left side.

Since the right side is a pattern, it can contain anot(非|gate)her extract(擷取|又：抽取)or(或|gate). The following example "chains" two extract(擷取|又：抽取)or(或|gate)s:

<!-- [code asset](assets/Extractor4.hx) -->
```haxe
class Main {
  static public function main() {
    switch (3) {
      case add(_, 1) => mul(_, 3) => a:
        trace(a);
    }
  }

  static function add(i1:Int, i2:Int) {
    return i1 + i2;
  }

  static function mul(i1:Int, i2:Int) {
    return i1 * i2;
  }
}
```

This traces `12` as a result of the call(呼叫|)s to `add(3, 1)`, where `3` is the match(匹配|)ed value(值|), and(及|gate) `mul(4, 3)` where `4` is the result of the `add` call(呼叫|). It is wor(或|gate)th not(非|gate)ing that the `a` on the right side of the second `=>` operator(運算子|) is a [capture variable(變數|)](lf-pattern-matching-variable-capture).

It is currently not(非|gate) possible to use extract(擷取|又：抽取)or(或|gate)s within [or(或|gate)-patterns](lf-pattern-match(匹配|)ing-or(或|gate)):

<!-- [code asset](assets/Extractor5.hx) -->
```haxe
class Main {
  static public function main() {
    switch ("foo") {
      // Extractors in or patterns are not allowed
      case(_.toLowerCase() => "foo") | "bar":
    }
  }
}
```

However, it is possible to have or(或|gate)-patterns on the right side of an extract(擷取|又：抽取)or(或|gate), so the previous example would compile without the parentheses.

<!--label:lf-pattern-matching-exhaustiveness-->
#### exhaustiveness(完整性|TODO:) checks

The compiler(編譯器|) ensures that no possible cases are for(或|gate)gotten:

```haxe
switch (true) {
    case false:
} // Unmatched patterns: true
```

The matched type `Bool` admits two value(值|)s `true` and(及|gate) `false`, but only `false` is checked.

exhaustiveness(完整性|TODO:) is not(非|gate) checked when match(匹配|)ing on `Int`, `Float` or(或|gate) `String` if no value(值|) from the switch is required, which means that it appears at block(塊段|)-level.

<!--label:lf-pattern-matching-unused-->
#### Useless pattern checks

In a similar fashion, the compiler(編譯器|) detects patterns which will never match(匹配|) the input value(值|):

```haxe
switch (Leaf("foo")) {
    case Leaf(_)
       | Leaf("foo"): // This pattern is unused
    case Node(l,r):
    case _: // This pattern is unused
}
```

<!--label:lf-pattern-matching-single-->
#### Single pattern check

The compiler provides the function `match` to check if an enum(枚舉|) value(值|) match(匹配|)es a given pattern:

<!-- [code asset](assets/PatternMatching10.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
trace(myTree.match(Leaf(_))); // false
trace(myTree.match(Node(_) | Leaf(_))); // true
trace(myTree.match(Node(Leaf("foo"), _))); // true
```

As this function(函式|) only tests if the pattern is match(匹配|)ed, guards and(及|gate) variable(變數|) capture are unavailable.

The `match` function(函式|) is equivalent to a `switch` with a single `case` for(或|gate) the given pattern, return(回傳|)ing `true`, and a `default` return(回傳|)ing `false`.

<!-- [code asset](assets/PatternMatching11.hx) -->
```haxe
var myTree = Node(Leaf("foo"), Node(Leaf("bar"), Leaf("foobar")));
myTree.match(Node(_));
// is equivalent to
switch (myTree) {
  case Node(_):
    true;
  case _:
    false;
}
```

See the [EnumValue API documentation (since Haxe 3.2.1)](https://api.haxe.org/haxe/EnumValueTools.html#match) for more information.

<!--label:lf-string-interpolation-->
### String Interpolation

With Haxe 3 it is no longer necessary to manually concatenate parts of a string due to the introduction of **String Interpolation**. Special identifiers, denoted by the dollar sign `$` within a string(字串|) enclosed(括住|) by single-quote `'` characters, are evaluate(評估|)d as if they were concatenated identifier(識別符|)s:

```haxe
var x = 12;
// The value of x is 12
trace('The value of x is $x');
```

Furthermore, it is possible to include whole expressions in the string by using `${expr}`, with `expr` being any(任意|) valid(有效|) Haxe expression(運算式|):

```haxe
var x = 12;
// The sum of 12 and 3 is 15
trace('The sum of $x and 3 is ${x + 3}');
```

String interpolation is a compile-time feature and has no impact on the runtime. The above example is equivalent to manual concatenation, which is exactly what the compiler generates:

```haxe
trace("The sum of " + x + " and 3 is " + (x + 3));
```

Of course the use of single-quote enclosed strings without any interpolation remains valid, but care has to be taken regarding the $ character as it triggers interpolation. If an actual dollar-sign should be used in the string, `$$` can be used.

> ##### Trivia: string interpolation(字串插值|) before(前於|) Haxe 3
>
> string interpolation(字串插值|) has been a Haxe feature(特徵|) since version 2.09. Back then, the macro(巨集|) `Std.format` had to be used, being both slower and(及|gate) less comfor(或|gate)table than the new string interpolation(字串插值|) syntax(語法|).

<!--label:lf-array-comprehension-->
### array(陣列|) comprehension(理解|)

array(陣列|) comprehension(理解|) in Haxe combines [array(陣列|) declaration(宣告|)](expression-array-declaration) and(及|gate) loop(迴圈|又：循環)s to allow(容許|又：允許) concise initialization(初始化|) of array(陣列|)s. It is identified by [`for`](expression-for) or [`while`](expression-while) constructs:

<!-- [code asset](assets/ArrayComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [for (i in 0...10) i];
    trace(a); // [0,1,2,3,4,5,6,7,8,9]

    var i = 0;
    var b = [while (i < 10) i++];
    trace(b); // [0,1,2,3,4,5,6,7,8,9]
  }
}
```

Variable `a` is initialize(初始化|)d to an array(陣列|) hold(儲存|TODO:又：存儲)ing the numbers 0 to 9. The compiler(編譯器|) generate(產生|)s code which adds the value(值|) of each loop(迴圈|又：循環) iteration(疊代|) to the array(陣列|), so the following code would be equivalent:

```haxe
var a = [];
for (i in 0...10) a.push(i);
```

Variable `b` is initialize(初始化|)d to an array(陣列|) with the same value(值|)s, but through a different comprehension(理解|) style using `while` instead of `for`. Again, the following code would be equivalent:

```haxe
var i = 0;
var b = [];
while(i < 10) b.push(i++);
```

The loop expression can be anything, including conditions and nested loops, so the following works as expected:

<!-- [code asset](assets/AdvArrayComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [
      for (a in 1...11)
        for (b in 2...4)
          if (a % b == 0)
            a + "/" + b
    ];
    // [2/2,3/3,4/2,6/2,6/3,8/2,9/3,10/2]
    trace(a);
  }
}
```

<!--label:lf-map-comprehension-->
### Map Comprehension

Map comprehension in Haxe is similar to array comprehension, but just like [map declaration](expression-map-declaration), it additionally uses the `=>` operator(運算子|):

<!-- [code asset](assets/MapComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [for (i in 0...5) i => 'number ${i}'];
    trace(a); // {0 => number 0, 1 => number 1, 2 => number 2, 3 => number 3, 4 => number 4}

    var i = 0;
    var b = [while (i < 5) i => 'number ${i++}'];
    trace(b); // {0 => number 0, 1 => number 1, 2 => number 2, 3 => number 3, 4 => number 4}
  }
}
```

variable(變數|) `a` is initialize(初始化|)d to an `Map` hold(儲存|TODO:又：存儲)ing keys from 0 to 4 and(及|gate) string(字串|) value(值|)s. The compiler(編譯器|) generate(產生|)s code which adds the value(值|) of each loop(迴圈|又：循環) iteration(疊代|) to the map(映射|), so the following code would be equivalent:

```haxe
var a = new Map();
for (i in 0...5) a.set(i, 'number ${i}');
```

Variable `b` is initialize(初始化|)d to an `Map` with the same keys and(及|gate) value(值|)s, but through a different comprehension(理解|) style using `while` instead of `for`. Again, the following code would be equivalent:

```haxe
var i = 0;
var b = new Map();
while(i < 5) b.set(i, 'number ${i++}');
```

The loop expression can be anything, including conditions and nested loops, so the following works as expected:

<!-- [code asset](assets/AdvMapComprehension.hx) -->
```haxe
class Main {
  static public function main() {
    var a = [
      for (x in 0...5)
        for (y in 0...5)
          if (x != y)
            x => y
    ];
    // {0 => 4, 1 => 4, 2 => 4, 3 => 4, 4 => 3}
    trace(a);
  }
}
```

<!--label:lf-iterators-->
### Iterators

With Haxe it is very easy to define custom iterators and iterable data types. These concepts are represented by the types `Iterator<T>` and(及|gate) `Iterable<T>` respectively:

```haxe
typedef Iterator<T> = {
  function hasNext():Bool;
  function next():T;
}

typedef Iterable<T> = {
  function iterator():Iterator<T>;
}
```

Any [class](types-class-instance) which [structurally unifies](type-system-structural-subtyping) with one of these types can be iterated over using a [for-loop](expression-for). That is, if the class defines methods `hasNext` and(及|gate) `next` with match(匹配|)ing return(回傳|) type(型式/型式化|n./v. 又：型別)s it is considered an iterator(疊代器|), if it define(定義|)s a method(方法|) `iterator` return(回傳|)ing an `Iterator<T>` it is considered an iterable type(型式/型式化|n./v. 又：型別).

<!-- [code asset](assets/Iterator.hx) -->
```haxe
class MyStringIterator {
  var s:String;
  var i:Int;

  public function new(s:String) {
    this.s = s;
    i = 0;
  }

  public function hasNext() {
    return i < s.length;
  }

  public function next() {
    return s.charAt(i++);
  }
}

class Main {
  static public function main() {
    var myIt = new MyStringIterator("string");
    for (chr in myIt) {
      trace(chr);
    }
  }
}
```

The type(型式/型式化|n./v. 又：型別) `MyStringIterator` in this example qualifies as iterator(疊代器|): It define(定義|)s a method(方法|) `hasNext` return(回傳|)ing `Bool` and(及|gate) a method(方法|) `next` return(回傳|)ing `String`, making it compatible with `Iterator<String>`. The `main` method(方法|) instantiate(實例化|)s it, then iterate(疊代|)s over it.

<!-- [code asset](assets/Iterable.hx) -->
```haxe
class MyArrayWrap<T> {
  var a:Array<T>;

  public function new(a:Array<T>) {
    this.a = a;
  }

  public function iterator() {
    return a.iterator();
  }
}

class Main {
  static public function main() {
    var myWrap = new MyArrayWrap([1, 2, 3]);
    for (elt in myWrap) {
      trace(elt);
    }
  }
}
```

Here we do not(非|gate) setup a full iterator(疊代器|) like in the previous example, but instead define(定義|) that the `MyArrayWrap<T>` has a method(方法|) `iterator`, effectively forwarding the iterator method of the wrapped `Array<T>` type(型式/型式化|n./v. 又：型別).

##### since Haxe 4.0.0

The standard library(標準函式庫|) also includes key-value(值|) iterator(疊代器|)s to suppor(或|gate)t [key-value(值|) iteration(疊代|)](expression(運算式|)-for(或|gate)#key-value(值|)-iteration(疊代|)):

```haxe
typedef KeyValueIterator<K, V> = {
  function hasNext():Bool;
  function next():{key:K, value:V};
}

typedef KeyValueIterable<K, V> = {
  function keyValueIterator():KeyValueIterator<K, V>;
}
```

##### Related content

* See the [Iterator API documentation](http://api.haxe.org/Iterator.html).
* [Haxe snippets and tutorials about iterators](http://code.haxe.org/tag/iterator.html) in the Haxe Code Cookbook.

<!--label:lf-function-bindings-->
### Function Bindings

Haxe 3 allows binding functions with partially applied arguments. Each function type can be considered to have a `bind` field(欄位|), which can be call(呼叫|)ed with the desired number of argument(引數|)s in or(或|gate)der to create(建立|) a new function(函式|). This is demonstrated here:

<!-- [code asset](assets/Bind.hx) -->
```haxe
class Main {
  static public function main() {
    var map = new haxe.ds.IntMap<String>();
    var f = map.set.bind(_, "12");
    $type(map.set); // Int -> String -> Void
    $type(f); // Int -> Void
    f(1);
    f(2);
    f(3);
    trace(map); // {1 => 12, 2 => 12, 3 => 12}
  }
}
```

line(列|) 4 bind(繫結|)s the function(函式|) `map.set` to a variable(變數|) name(名稱|)d `f`, and applies `12` as second argument(引數|). The underscore(底線|) `_` is used to denote(表示|) that this argument(引數|) is not(非|gate) bound(繫結|), which is shown by comparing the type(型式/型式化|n./v. 又：型別)s of `map.set` and(及|gate) `f`: The bound `String` argument(引數|) is effectively cut from the type(型式/型式化|n./v. 又：型別), turning a `Int->String->Void` type(型式/型式化|n./v. 又：型別) into `Int->Void`.

A call to `f(1)` then actually invoke(引動|)s `map.set(1, "12")`, the calls to `f(2)` and(及|gate) `f(3)` are analog(記錄|)ous. The last line(列|) proves that all three indices indeed are map(映射|)ped to the value(值|) `"12"`.

The underscore `_` can be skip(跳過|)ped for(或|gate) trailing argument(引數|)s, so the first argument(引數|) could be bound(繫結|) through `map.set.bind(1)`, yielding a `String->Void` function(函式|) that sets a new value(值|) for(或|gate) index(索引|) `1` on invocation(引動|).

##### optional(任選|) argument(引數|)s

By default(預設|), trailing optional(任選|) argument(引數|)s are bound(繫結|) to their default(預設|) value(值|)s and(及|gate) do not(非|gate) become argument(引數|)s of the result function(函式|). This can be changed by using an explicit(明確|) underscore(底線|) `_` instead, in which case the optional(任選|) argument(引數|) of the or(或|gate)iginal function(函式|) becomes a non-optional(任選|) argument(引數|) of the result function(函式|).
<!-- [code asset](assets/BindOptional.hx) -->
```haxe
class Main {
  static function test(a:Int, ?b:String):Void {}

  static public function main() {
    var fn = test.bind(1);
    $type(fn); // Void->Void
    fn('foo'); // Compiler error: Too many arguments

    var fn = test.bind(1, _);
    $type(fn); // ?String->Void
    fn('foo'); // works
  }
}
```

> ##### Trivia: call(呼叫|)back
>
> Prior(或|gate) to Haxe 3, Haxe used to know a `callback`-keyword which could be called with a function argument followed by any number of binding arguments. The name originated from a common usage were a callback-function is created with the this-object being bound.
>
> Callback would allow binding of arguments only from left to right as there was no support for the underscore `_`. The choice to use an underscore was controversial and several other suggestions were made, none of which were considered superior. After all, the underscore `_` at least looks like it's saying "fill value(值|) in here", which nicely describe(描述|)s its semantic(語意|)s.

<!--label:lf-metadata-->
### metadata(元資料|)

Several construct(建構/構造|v./n.)s can be attributed with custom(客製|) metadata(元資料|):

* `class` and(及|gate) `enum` declaration(宣告|)s
* class(類別|) field(欄位|)s
* enum(枚舉|) constructor(建構式|)s
* expression(運算式|)s

These metadata(元資料|) infor(或|gate)mation can be obtained at runtime through the `haxe.rtti.Meta` API:

<!-- [code asset](assets/Meta.hx) -->
```haxe
import haxe.rtti.Meta;

@author("Nicolas")
@:keep
class MyClass {
  @range(1, 8)
  var value:Int;

  @broken
  static function method() {}
}

class Main {
  static public function main() {
    // { author : ["Nicolas"] }
    trace(Meta.getType(MyClass));
    // [1,8]
    trace(Meta.getFields(MyClass).value.range);
    // { broken: null }
    trace(Meta.getStatics(MyClass).method);
  }
}
```

We can easily identify metadata(元資料|) by the leading `@` character, followed by the metadata(元資料|) name(名稱|) and(及|gate), optional(任選|)ly, by a number of comma-separated(分隔|) constant(常數|) argument(引數|)s enclosed(括住|) in parentheses.

* class(類別|) `MyClass` has an `author` metadata(元資料|) with a single string(字串|) argument(引數|) `"Nicolas"`, as well as a `:keep` metadata(元資料|) without argument(引數|)s.
* The member(成員|) variable(變數|) `value` has a `range` metadata(元資料|) with two Int argument(引數|)s `1` and(及|gate) `8`.
* The static method `method` has a `broken` metadata(元資料|) without argument(引數|)s.

The `main` method(方法|) access(存取|)es these metadata(元資料|) value(值|)s using their API. The output reveals the structure(結構|) of the obtained data(資料|):

* There is a field(欄位|) for(或|gate) each metadata(元資料|), with the field(欄位|) name(名稱|) being the metadata(元資料|) name(名稱|).
* The field(欄位|) value(值|)s correspond(對應|) to the metadata(元資料|) argument(引數|)s. If there are no argument(引數|)s, the field(欄位|) value(值|) is `null`. Otherwise the field value is an array with one element per argument.

Allowed values for metadata arguments are:

* [Constants](expression-constants)
* [Arrays declarations](expression-array-declaration) (if all their elements qualify)
* [Object declarations](expression-object-declaration) (if all their field values qualify)

##### Compile-time Metadata

Metadata starting with `:`, such as `@:keep`, is available at compile time only; it is omitted at runtime. It may be used by macros or by the Haxe compiler itself. Unlike runtime metadata, arguments to compile-time metadata can be any valid expression.

##### Built-in Compiler Metadata

An exhaustive list of all defined metadata can be obtained by running `haxe --help-metas` from command(及|gate) line(列|).

##### since Haxe 4.0.0

Prior(或|gate) to Haxe 4, metadata(元資料|) name(名稱|)s had to be valid(有效|) identifier(識別符|)s. Starting in Haxe 4, metadata(元資料|) name(名稱|)s can consist of multiple identifier(識別符|)s separated(分隔|) by `.` symbols. This change was primarily intended to make it easier to or(或|gate)ganize compile-time(編譯期|又：編譯時) metadata(元資料|). Runtime metadata(元資料|) with such a name(名稱|) can only be access(存取|)ed via [dynamic(動態|) access(存取|)](types-dynamic-access).

##### Related content

* See also the [compiler(編譯器|) metadata(元資料|) list(列表|)](cr-metadata).

<!--label:lf-access-control-->
### access(存取|) Control

access(存取|) control can be used if the basic [visibility(可見性|)](class-field-visibility) options are not(非|gate) sufficient. It is applicable at **class(類別|)-level** and(及|gate) at **field(欄位|)-level** and(及|gate) knows two directions:

* allow(容許|又：允許)ing access(存取|): The target(目標|) is granted access(存取|) to the given class(類別|) or(或|gate) field(欄位|) by using the `:allow(target)` [metadata(元資料|)](lf-metadata).
* For(或|gate)cing access(存取|): A target(目標|) is for(或|gate)ced to allow(容許|又：允許) access(存取|) to the given class(類別|) or(或|gate) field(欄位|) by using the `:access(target)` [metadata(元資料|)](lf-metadata).

In this context, a **target(目標|)** can be the [dot-path(路徑|)](define(定義|)-type(型式/型式化|n./v. 又：型別)-path(路徑|)) to

* a **class(類別|) field(欄位|)**,
* a **class(類別|)** or(或|gate) **abstract(抽象|)** type(型式/型式化|n./v. 又：型別), or(或|gate)
* a **package(套件|)**.

target(目標|) does **not(非|gate)** respect import(匯入|)s, so the fully qualified path(路徑|) has to be used.

If it is a class(類別|) or(或|gate) abstract(抽象|) type(型式/型式化|n./v. 又：型別), access(存取|) modification extend(擴充|又：延伸)s to all field(欄位|)s of that type(型式/型式化|n./v. 又：型別). Likewise, if it is a package(套件|), access(存取|) modification extend(擴充|又：延伸)s to all type(型式/型式化|n./v. 又：型別)s of that package(套件|) and(及|gate) recursively to all field(欄位|)s of these type(型式/型式化|n./v. 又：型別)s.

<!-- [code asset](assets/ACL.hx) -->
```haxe
@:allow(Main)
class MyClass {
  static private var foo:Int;
}

class Main {
  static public function main() {
    MyClass.foo;
  }
}
```

Here, `MyClass.foo` can be access(存取|)ed from the `main`-method because `MyClass` is annotate(標記|)d with `@:allow(Main)`. This would also work with `@:allow(Main.main)` and(及|gate) both versions could alternative(替代|)ly be annotate(標記|)d to the field(欄位|) `foo` instead of the class(類別|) `MyClass`:

<!-- [code asset](assets/ACL2.hx) -->
```haxe
class MyClass {
  @:allow(Main.main)
  static private var foo:Int;
}

class Main {
  static public function main() {
    MyClass.foo;
  }
}
```

If a type cannot be modified to allow this kind of access, the accessing method may force access:

<!-- [code asset](assets/ACL3.hx) -->
```haxe
class MyClass {
  static private var foo:Int;
}

class Main {
  @:access(MyClass.foo)
  static public function main() {
    MyClass.foo;
  }
}
```

The `@:access(MyClass.foo)` annotation(表示法|) effectively subvert(顛覆|TODO:)s the visibility(可見性|) of the `foo` field(欄位|) within the `main`-method.

> ##### Trivia: On the choice of metadata
>
> The access control language feature uses the Haxe metadata syntax instead of additional language-specific syntax. There are several reasons for that:
>
>
> * Additional syntax often adds complexity to the language parsing, and also adds (too) many keywords.
> * Additional syntax requires additional learning by the language user, whereas metadata syntax is something that is already known.
> * The metadata syntax is flexible enough to allow extension of this feature.
> * The metadata can be accessed/generated/modified by Haxe macros.
>
> Of course, the main drawback of using metadata syntax is that you get no error report in case you misspell either the metadata key (@:access for instance) or the class/package name. However, with this feature you will get an error when you try to access a private field that you are not allowed to, therefore there is no possibility for silent errors.

##### since Haxe 3.1.0

If access is allowed to an [interface](types-interfaces), it extends to all classes implementing that interface:

<!-- [code asset](assets/ACL4.hx) -->
```haxe
class MyClass {
  @:allow(I)
  static private var foo:Int;
}

interface I {}

class Main implements I {
  static public function main() {
    MyClass.foo;
  }
}
```

This is also true for access granted to parent classes, in which case it extends to all child classes.

> ##### Trivia: Broken feature
>
> Access extension to child classes and implementing classes was supposed to work in Haxe 3.0 and even documented accordingly. While writing this manual it was found that this part of the access control implementation was simply missing.

<!--label:lf-inline-constructor-->
### Inline Constructors

##### since Haxe 3.1.0

If a constructor is declared to be [inline](class-field-inline), the compiler may try to optimize it away in certain situations. There are several requirements for this to work:

* The result of the constructor call must be directly assigned to a local variable.
* The expression of the constructor field must only contain assignments to its fields.

The following example demonstrates constructor inlining:

<!-- [code asset](assets/NewInline.hx) -->
```haxe
class Point {
  public var x:Float;
  public var y:Float;

  public inline function new(x:Float, y:Float) {
    this.x = x;
    this.y = y;
  }
}

class Main {
  static public function main() {
    var pt = new Point(1.2, 9.3);
  }
}
```

A look at the JavaScript output reveals the effect:

```js
Main.main = function() {
  var pt_x = 1.2;
  var pt_y = 9.3;
};
```
